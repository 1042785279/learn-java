
# Java ⭐⭐⭐⭐⭐
## 语言基础

### 1. 关于HashMap的一切⭐⭐⭐⭐⭐

```
0.常见的问题引导方式：HashMap是线程安全的吗，并发下使用的Map是什么。他们的内部原理分别是什么，比如存储方式，hashcode，扩容，默认容量等。

1. 什么时候会使用HashMap？他有什么特点？
是基于Map接口的实现，存储键值对时，它可以接收null的键值，是非同步的，HashMap存储着Entry(hash, key, value, next)对象。

2. 你知道HashMap的工作原理吗？
通过hash的方法，通过put和get存储和获取对象。存储对象时，我们将K/V传给put方法时，它调用hashCode计算hash从而得到bucket位置，进一步存储，HashMap会根据当前bucket的占用情况自动调整容量(超过Load Facotr则resize为原来的2倍)。获取对象时，我们将K传给get，它调用hashCode计算hash从而得到bucket位置，并进一步调用equals()方法确定键值对。如果发生碰撞的时候，Hashmap通过链表将产生碰撞冲突的元素组织起来，在Java 8中，如果一个bucket中碰撞冲突的元素超过某个限制(默认是8)，则使用红黑树来替换链表，从而提高速度。

3. 你知道get和put的原理吗？equals()和hashCode()的都有什么作用？
通过对key的hashCode()进行hashing，并计算下标( n-1 & hash)，从而获得buckets的位置。如果产生碰撞，则利用key.equals()方法去链表或树中去查找对应的节点

4. 你知道hash的实现吗？为什么要这样实现？
在Java 1.8的实现中，是通过hashCode()的高16位异或低16位实现的：(h = k.hashCode()) ^ (h >>> 16)，主要是从速度、功效、质量来考虑的，这么做可以在bucket的n比较小的时候，也能保证考虑到高低bit都参与到hash的计算中，同时不会有太大的开销。

5. 如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？
如果超过了负载因子(默认0.75)，则会重新resize一个原来长度两倍的HashMap，并且重新调用hash方法。
```

put函数大致的思路为：

1. 对key的hashCode()做hash，然后再计算index;
2. 如果没碰撞直接放到bucket里；
3. 如果碰撞了，以链表的形式存在buckets后；
4. 如果碰撞导致链表过长(大于等于TREEIFY_THRESHOLD)，就把链表转换成红黑树；
5. 如果节点已经存在就替换old value(保证key的唯一性)
6. 如果bucket满了(超过load factor*current capacity)，就要resize。

在理解了put之后，get就很简单了。大致思路如下：

1. bucket里的第一个节点，直接命中；
2. 如果有冲突，则通过key.equals(k)去查找对应的entry
   若为树，则在树中通过key.equals(k)查找，O(logn)；
   若为链表，则在链表中通过key.equals(k)查找，O(n)。

#### 1. resize机制，扩容的过程，为什么是2倍?

```

```



#### 2. 既然有resize机制，当存放的键值对很少时，是否有缩容机制？

```

```



#### 3. 能否自己实现一个Hashmap？ 

```

```

#### 4. HashSet的实现原理

```

```



重新认识Hashmap：https://tech.meituan.com/2016/06/24/java-hashmap.html

Java HashMap工作原理及实现：[https://yikun.github.io/2015/04/01/Java-HashMap%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/](https://yikun.github.io/2015/04/01/Java-HashMap工作原理及实现/)

### 2. 谈一谈你了解的ConcurrentHashMap ⭐⭐⭐

```java
/**
 * Segment 数组，存放数据时首先需要定位到具体的 Segment 中。
 */
final Segment<K,V>[] segments;
transient Set<K> keySet;
transient Set<Map.Entry<K,V>> entrySet;
```

```java
 static final class Segment<K,V> extends ReentrantLock implements Serializable {
       private static final long serialVersionUID = 2249069246763182397L;
       
       // 和 HashMap 中的 HashEntry 作用一样，真正存放数据的桶
       transient volatile HashEntry<K,V>[] table;
       transient int count;
       transient int modCount;
       transient int threshold;
       final float loadFactor;
       
}
```

Segment继承自ReentrantLock

![](pics/concurrenthashmap.jpg)

ConcurrencyHashMap和HashSet的区别？

```
原理上来说：ConcurrentHashMap 采用了分段锁技术，其中 Segment 继承于 ReentrantLock。不会像 HashTable 那样不管是 put 还是 get 操作都需要做同步处理，理论上 ConcurrentHashMap 支持 CurrencyLevel (Segment 数组数量)的线程并发。每当一个线程占用锁访问一个 Segment 时，不会影响到其他的 Segment。
```





### 3.  说一说你对java.lang.Object对象中的hashCode和equals方法的理解，在什么场景下需要重新实现这两个方法⭐⭐⭐

#### 3.1 equals方法的作用

`equals()`方法是用来判断其他的对象是否和该对象相等，equals()方法在object类中定义如下： 

```
public boolean equals(Object obj) {  
    return (this == obj);   //比较的是地址
}  
```

Override Equals方法时的规则：

- **自反性**：对于任何非空引用值 x，x.equals(x) 都应返回 true。

- **对称性**：对于任何非空引用值 x 和 y，当且仅当 y.equals(x) 返回 true 时，x.equals(y) 才应返回 true。

- **传递性**：对于任何非空引用值 x、y 和 z，如果 x.equals(y) 返回 true， 并且 y.equals(z) 返回 true，那么 x.equals(z) 应返回 true。

- **一致性**：对于任何非空引用值 x 和 y，多次调用 x.equals(y) 始终返回 true 或始终返回 false， 前提是对象上 equals 比较中所用的信息没有被修改。

- **非空性**：对于任何非空引用值 x，x.equals(null) 都应返回 false。

#### 3.2 重写equals为什么要重写hashcode

**为了保证使用Map接口时，“相同”对象的hashCode也是相同的**

HashMap对象是根据其Key的hashCode来获取对应的Value。

在重写父类的equals方法时，也重写hashcode方法，使相等的两个对象获取的HashCode也相等，这样当此对象做Map类中的Key时，两个equals为true的对象其获取的value都是同一个，比较符合实际。

#### 3.3 equals和hashCode的关系

一个好的hashCode的方法的目标：**为不相等的对象产生不相等的散列码**，同样的，相等的对象必须拥有相等的散列码。

**如果两个对象equals，那么它们的hashCode必然相等，但是hashCode相等，equals不一定相等。**

### 4. ⭐⭐⭐⭐⭐

```

```



如何深入研究Java里的课题：https://blog.csdn.net/javazejian/article/details/73413292

### 5. Java中的几种基本数据类型是什么，各占用多少字节 ⭐⭐⭐

以int 32位作为基准，其他的double or half

![](pics/java_basic_data_type.png)

### 6. String类能够被继承吗，为什么 ⭐⭐⭐

```
直接原因：不能，被final修饰。
根本原因：
（1）为了安全考虑，比如下面的例子，在将String参数传入函数之后不会发生改变，对比StringBuffer
（2）为了效率考虑：在大量使用字符串的时候，指向的是常量池中同一个常量，节省内存空间，提高效率
```

![](pics/string_final.png)

### 7. 反射机制 ⭐⭐⭐⭐⭐

 ```
Java 反射机制在程序运行时，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性。这 动态的获取信息 以及 动态调用对象的方法 的功能称为 java 的反射机制。

反射机制很重要的一点就是“运行时”，其使得我们可以在程序运行时加载、探索以及使用编译期间完全未知的 .class 文件。换句话说，Java 程序可以加载一个运行时才得知名称的 .class 文件，然后获悉其完整构造，并生成其对象实体、或对其 fields（变量）设值、或调用其 methods（方法）。
 ```

一个demo:

```java
/**
 * 通过反射获取类的所有变量
 */
private static void printFields(){
    //主要是首先获取对象的Class类
    //1.获取并输出类的名称
    Class mClass = SonClass.class;
    System.out.println("类的名称：" + mClass.getName());

    //2.1 获取所有 public 访问权限的变量
    // 包括本类声明的和从父类继承的
    Field[] fields = mClass.getFields();

    //2.2 获取所有本类声明的变量（不问访问权限）
    //Field[] fields = mClass.getDeclaredFields();

    //3. 遍历变量并输出变量信息
    for (Field field :
            fields) {
        //获取访问权限并输出
        int modifiers = field.getModifiers();
        System.out.print(Modifier.toString(modifiers) + " ");
        //输出变量的类型及变量名
        System.out.println(field.getType().getName()
                 + " " + field.getName());
    }
}
```

获取Class对象三种方式：

- 通过对象.getClass（）方式
- 通过类名.Class 方式
- 通过Class.forName 方式

### 8. Stirng，StringBuffer，StringBuilder的区别 ⭐⭐⭐

StringBuffer类是线程安全的，StringBuilder不是线程安全的；

```
1、String类型和StringBuffer类型的主要性能区别：String是不可变的对象，因此每次在对String类进行改变的时候都会生成一个新的string对象，然后将指针指向新的string对象，所以经常要改变字符串长度的话不要使用string，因为每次生成对象都会对系统性能产生影响，特别是当内存中引用的对象多了以后，JVM的GC就会开始工作，性能就会降低；

2、使用StringBuffer类时，每次都会对StringBuffer对象本身进行操作，而不是生成新的对象并改变对象引用，所以多数情况下推荐使用StringBuffer，特别是字符串对象经常要改变的情况；
```

### 9. Java里面的“假泛型”听说过吗？ ⭐⭐⭐

```java
    public static void main(String[] args) throws Exception {
        List<Integer> list = new ArrayList<>();
        list.add(1);
        //list.add("a"); // 这样直接添加肯定是不允许的

        //下面通过java的反射，绕过泛型来给添加字符串
        Method add = list.getClass().getMethod("add", Object.class);
        add.invoke(list,"a");

        System.out.println(list); //[1, a] 输出没有没问题
        System.out.println(list.get(1)); //a
    }
```

通过运行时的反射机制能够绕过泛型的编译验证

**泛型擦除：**

Java中的泛型基本上都是在编译器这个层次来实现的。在生成的Java字节码中是不包含泛型中的类型信息的。**使用泛型的时候加上的类型参数，会在编译器在编译的时候去掉。**这个过程就称为类型擦除。

如在代码中定义的List<object>和List<String>等类型，在编译后都会编程List。JVM看到的只是List，而由泛型附加的类型信息对JVM来说是不可见的。Java编译器会在编译时尽可能的发现可能出错的地方，但是仍然无法避免在运行时刻出现类型转换异常的情况。类型擦除也是Java的泛型实现方法与C++模版机制实现方式之间的重要区别。

### 10. 深拷贝和浅拷贝的区别  ⭐⭐⭐

**创建对象的五种方式，Object类的clone方法是重点：**

​       **①、通过 new 关键字**

　　这是最常用的一种方式，通过 new 关键字调用类的有参或无参构造方法来创建对象。比如 Object obj = new Object();

　　**②、通过 Class 类的 newInstance() 方法**

　　这种默认是调用类的无参构造方法创建对象。比如 Person p2 = (Person) Class.forName("com.ys.test.Person").newInstance();

　　**③、通过 Constructor 类的 newInstance 方法**

　　这和第二种方法类时，都是通过反射来实现。通过 java.lang.relect.Constructor 类的 newInstance() 方法指定某个构造器来创建对象。

　　Person p3 = (Person) Person.class.getConstructors()[0].newInstance();

　　实际上第二种方法利用 Class 的 newInstance() 方法创建对象，其内部调用还是 Constructor 的 newInstance() 方法。

　　**④、利用 Clone 方法**

　　Clone 是 Object 类中的一个方法，通过 对象A.clone() 方法会创建一个内容和对象 A 一模一样的对象 B，clone 克隆，顾名思义就是创建一个一模一样的对象出来。

　　Person p4 = (Person) p3.clone();

　　**⑤、反序列化**

　　序列化是把堆内存中的 Java 对象数据，通过某种方式把对象存储到磁盘文件中或者传递给其他网络节点（在网络上传输）。而反序列化则是把磁盘文件中的对象数据或者把网络节点上的对象数据，恢复成Java对象模型的过程。

**浅拷贝通过Object.clone()方法实现：**

![](pics/shallow_clone.png)

**浅拷贝：创建一个新对象，然后将当前对象的非静态字段复制到该新对象，如果字段是值类型的，那么对该字段执行复制；如果该字段是引用类型的话，则复制引用但不复制引用的对象。因此，原始对象及其副本引用同一个对象。**

![](pics/deep_clone.png)

**深拷贝：创建一个新对象，然后将当前对象的非静态字段复制到该新对象，无论该字段是值类型的还是引用类型，都复制独立的一份。当你修改其中一个对象的任何内容时，都不会影响另一个对象的内容。**

**请问如何实现对象的深拷贝？**

​		序列化是将对象写到流中便于传输，而反序列化则是把对象从流中读取出来。这里写到流中的对象则是原始对象的一个拷贝，因为原始对象还存在 JVM 中，所以我们可以利用对象的序列化产生克隆对象，然后通过反序列化获取这个对象。

　　注意每个需要序列化的类都要实现 Serializable 接口，如果有某个属性不需要序列化，可以将其声明为 transient，即将其排除在克隆属性之外。

```java
//深度拷贝
public Object deepClone() throws Exception{
    // 序列化
    ByteArrayOutputStream bos = new ByteArrayOutputStream();
    ObjectOutputStream oos = new ObjectOutputStream(bos);

    oos.writeObject(this);

    // 反序列化
    ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());
    ObjectInputStream ois = new ObjectInputStream(bis);

    return ois.readObject();
}
```

### 11. ArrayList和LinkedList的区别，有线程安全的类吗？ ⭐⭐⭐

```
ArrayList是一个可以处理变长数组的类型，这里不局限于“数”组，ArrayList是一个泛型类，可以存放任意类型的对象。

LinkedList可以看做为一个双向链表，所有的操作都可以认为是一个双向链表的操作，因为它实现了Deque接口和List接口。

Vector也是一个类似于ArrayList的可变长度的数组类型，它的内部也是使用数组来存放数据对象的。值得注意的是Vector与ArrayList唯一的区别是，Vector是线程安全的，即它的大部分方法都包含有关键字synchronized。
若对于单一线程的应用来说，最好使用ArrayList代替Vector。
```









---



### 4. ArrayList和LinkedList有什么区别。
### 5. 讲一下类的实例化顺序，比如父类静态数据，构造函数，字段，子类静态数据，构造函数，字段，当new的时候，他们的执行顺序。
### 6. 用过哪些Map类，都有什么区别。


### 8. Java8的CocurrentHashMap为什么放弃了分段锁，有什么问题吗。如果你来设计，你如何设计。
### 9. 有没有顺序的Map实现类，如果有，他们是怎么保证有序的。
### 10. 抽象类和接口的区别，类可以继承多个类吗，接口可以继承多个接口吗，类可以实现多个接口吗。
### 11. 继承和聚合的区别是什么。
### 12. 反射的原理，反射创建类实例的三种方式是什么。
### 13. 反射中，Class.forName和ClassLoader的区别。
### 14. 描述动态代理的几种实现方式，分别说出相应的优缺点。 ⭐⭐⭐⭐

静态代理是Java中的一种设计模式。

动态代理的两种方式：https://www.jianshu.com/p/3caa0c23a157

```
动态代理和静态代理的区别：
普通代理模式，代理类Proxy的Java代码在JVM运行时就已经确定了，也就是在编码编译阶段就确定了Proxy类的代码。而动态代理是指在JVM运行过程中，动态的创建一个类的代理类，并实例化代理对象。因为实际的代理类是在运行时创建的。

(1)JDK动态代理方式
从类的结构可以看出，JDK动态生成代理类，一定要被代理类实现了某个接口，否则就无法生成代理类，这也就是JDK动态代理的缺陷之一。
另外，被代理类可以实现多个接口。从代理类代码中可以看到，代理类是通过InvocationHandler的invoke方法去实现被代理接口方法调用的。所以被代理对象实现了多个接口并且希望对不同接口实施不同的代理行为时，应该在ConcreteInvocationHandler类的invoke方法中，通过判断方法名来实现不同的接口的代理行为。


```



### 15. 为什么CGlib方式可以对接口实现代理。
### 16. final关键词的作用。
### 17. static关键词的作用。
### 18. 写出三种单例模式。
### 19. 如何在父类中为子类自动完成所有的hashcode和equals实现，这么做有何优劣。
### 20. 请结合OO设计理念，谈谈访问修饰符public、private、protected、default在应用中的设计。
### 21. 深拷贝和浅拷贝的区别。
### 22. 请枚举出5个运行时异常。
### 23. 在自己的代码中，如果创建一个java.lang.String类，这个类是否可以被类加载器加载，为什么。


### 25. 在JDK1.5中，引入了泛型，泛型的存在是用来解决什么问题。
### 26. 有没有可能2个不相等的对象有相同的hashcode。
### 27. 什么是序列化，什么是反序列化，反序列化会遇到什么问题，如何解决。
### 
### 29. 面向对象的三大特性，Java中实现多态的方式。
### 30. 抽象类和接口的相同点和不同点。
### 31. 谈一谈Java中的四种引用。
### 
###

### 



## I/O
### 1. IO模型有哪些 ⭐⭐⭐

![](pics/java_io.png)

### 2.  NIO，它和BIO，AIO的区别是啥 ⭐⭐⭐⭐⭐



美团技术文章：https://tech.meituan.com/2016/11/04/nio.html







---

### 2. 讲一下Reactor模型。
### 3. 同步阻塞、同步非阻塞、异步的区别。
### 4. select、poll、eopll 的区别。

## Java虚拟机
### 1. JVM内存的构成。⭐⭐⭐⭐⭐

```
内存分区是一个特别基础的概念，不过要结合Java实际编程来分析，理解更加深刻。

运行时数据区（Runtime Data）包含哪些部分？
```

![](pics/java_memory.png)

### 2. 谈一谈GC回收算法。⭐⭐⭐⭐⭐

在学习GC的时候保持一条主线：

- 要回收什么

-  如何判断对象是否需要回收

- 如何回收对象[占用的内存区域]

```
一、要回收哪些区域 
在JVM内存模型中，有三个是不需要进行垃圾回收的：程序计数器、JVM栈、本地方法栈。因为它们的生命周期是和线程同步的，随着线程的销毁，它们占用的内存会自动释放，所以只有方法区和堆需要进行GC

引用计数法：(无法解决循环引用的问题)
在这种方法中，堆中每个对象实例都有一个引用计数。当一个对象被创建时，就将该对象实例分配给一个变量，该变量计数设置为1。当任何其它变量被赋值为这个对象的引用时，计数加1（a = b,则b引用的对象实例的计数器+1），但当一个对象实例的某个引用超过了生命周期或者被设置为一个新值时，对象实例的引用计数器减1。任何引用计数器为0的对象实例可以被当作垃圾收集。当一个对象实例被垃圾收集时，它引用的任何对象实例的引用计数器减1。
```

二、如何判断对象是否需要回收

可达性分析算法是从离散数学中的图论引入的，程序把所有的引用关系看作一张图，**从一个节点GC ROOT开始**，寻找对应的引用节点，找到这个节点以后，**继续寻找这个节点的引用节点**，当所有的引用节点寻找完毕之后，剩余的节点则被认为是没有被引用到的节点，即无用的节点，无用的节点将会被判定为是可回收的对象。

在Java语言中，可作为GC Roots的对象包括下面几种： 
a) 虚拟机栈中引用的对象（栈帧中的本地变量表）； 
b) 方法区中类静态属性引用的对象； 
c) 方法区中常量引用的对象； 
d) 本地方法栈中JNI（Native方法）引用的对象。

![](pics/java_gc_reachable.png)

备注：

方法区如何判断是否需要回收 
方法区主要回收的内容有：废弃常量和无用的类。对于废弃常量也可通过引用的可达性来判断，但是对于无用的类则需要同时满足下面3个条件： 
① 该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例； 
② 加载该类的ClassLoader已经被回收； 

③ 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

三、回收算法

(1)标记-清除算法（Mark-Sweep）

标记-清除算法采用从根集合（GC Roots）进行扫描，对存活的对象进行标记，标记完毕后，再扫描整个空间中未被标记的对象，进行回收，此算法一般没有虚拟机采用。 

标记-清除算法分为两个阶段：标记阶段和清除阶段。标记阶段的任务是标记出所有需要被回收的对象，清除阶段就是回收被标记的对象所占用的空间。

优点1：解决了循环引用的问题 
优点2：与复制算法相比，不需要对象移动，效率较高，而且还不需要额外的空间 
不足1：每个活跃的对象都要进行扫描，而且要扫描两次，效率较低，收集暂停的时间比较长。 

不足2：产生不连续的内存碎片 

**备注：CMS垃圾回收器**

![](pics/java_gc_al1.png)

(2)复制算法（Copying）

将内存分成两块容量大小相等的区域，每次只使用其中一块，当这一块内存用完了，就将所有存活对象复制到另一块内存空间，然后清除前一块内存空间。这样一来就不容易出现内存碎片的问题。 
1、复制的代价较高，所以适合新生代，因为新生代的对象存活率较低，需要复制的对象较少； 

2、需要双倍的内存空间，而且总是有一块内存空闲，浪费空间 

**备注：Minor GC**

![](pics/java_gc_al2.png)

(3)标记-整理算法（Mark-Compact）

在完成标记之后，它不是直接清理可回收对象，而是将存活对象都向一端移动，然后清理掉端边界以外的内存。 
特点：不会产生内存碎片，但是依旧移动对象的成本。

![](pics/java_gc_al3.png)

**备注：FullGC**

(4)分代搜集算法（Generational Collection）

分代收集算法是目前大部分JVM的垃圾收集器采用的算法。它的核心思想是**根据对象存活的生命周期**将内存划分为若干个不同的区域。一般情况下**将堆区划分为老年代（Tenured Generation）和新生代（Young Generation）**,在堆区之外还有一个代就是永久代（Permanet Generation）。老年代的特点是每次垃圾收集时只有少量对象需要被回收，而新生代的特点是每次垃圾回收时都有大量的对象需要被回收，那么就可以根据不同代的特点采取最适合的收集算法。

新生代：Eden、from Survivor Space和to Survivor Space

![](pics/java_gc_al4.png)

[1]新生代回收算法

```
包含有Enden、form survicor space、to survivor space三个区，绝大多数最新被创建的对象会被分配到这里，大部分对象在创建之后会变得很快不可达。 
① 所有新生成的对象首先都是放在年轻代的。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。 
② 新生代内存按照8:1:1的比例分为一个eden区和两个survivor(survivor0,survivor1)区。一个Eden区，两个 Survivor区(一般而言)。大部分对象在Eden区中生成。回收时先将eden区存活对象复制到一个survivor0区，然后清空eden区，当这个survivor0区也存放满了时，则将eden区和survivor0区存活对象复制到另一个survivor1区，然后清空eden和这个survivor0区，此时survivor0区是空的，然后将survivor0区和survivor1区交换，即保持survivor1区为空， 如此往复。 
③ 当survivor1区不足以存放 eden和survivor0的存活对象时，就将存活对象直接存放到老年代。若是老年代也满了就会触发一次Full GC，也就是新生代、老年代都进行回收。 
④ 新生代发生的GC也叫做Minor GC，Minor GC发生频率比较高(不一定等Eden区满了才触发)。 
```

[2]老年代回收算法

```
① 在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。 
② 内存比新生代也大很多(大概比例是1:2)，当老年代内存满时触发Major GC即Full GC，Full GC发生频率比较低，老年代对象存活时间比较长，存活率标记高。 
```

**一般来说，老年代使用Mark-Sweep算法或者Mark-Compact算法，因为对象存活率高，不能使用额外空间担保。**

```
Java 中的堆也是 GC 收集垃圾的主要区域。GC 分为两种：Minor GC、Full GC ( 或称为 Major GC )。
Minor GC 是发生在新生代中的垃圾收集动作，所采用的是复制算法。
新生代几乎是所有 Java 对象出生的地方，即 Java 对象申请的内存以及存放都是在这个地方。Java 中的大部分对象通常不需长久存活，具有朝生夕灭的性质。
当一个对象被判定为 "死亡" 的时候，GC 就有责任来回收掉这部分对象的内存空间。新生代是 GC 收集垃圾的频繁区域。
当对象在 Eden ( 包括一个 Survivor 区域，这里假设是 from 区域 ) 出生后，在经过一次 Minor GC 后，如果对象还存活，并且能够被另外一块 Survivor 区域所容纳( 上面已经假设为 from 区域，这里应为 to 区域，即 to 区域有足够的内存空间来存储 Eden 和 from 区域中存活的对象 )，则使用复制算法将这些仍然还存活的对象复制到另外一块 Survivor 区域 ( 即 to 区域 ) 中，然后清理所使用过的 Eden 以及 Survivor 区域 ( 即 from 区域 )，并且将这些对象的年龄设置为1，以后对象在 Survivor 区每熬过一次 Minor GC，就将对象的年龄 + 1，当对象的年龄达到某个值时 ( 默认是 15 岁，可以通过参数 -XX:MaxTenuringThreshold 来设定 )，这些对象就会成为老年代。
但这也不是一定的，对于一些较大的对象 ( 即需要分配一块较大的连续内存空间 ) 则是直接进入到老年代。
Full GC 是发生在老年代的垃圾收集动作，所采用的是标记-清除算法。
现实的生活中，老年代的人通常会比新生代的人 "早死"。堆内存中的老年代(Old)不同于这个，老年代里面的对象几乎个个都是在 Survivor 区域中熬过来的，它们是不会那么容易就 "死掉" 了的。因此，Full GC 发生的次数不会有 Minor GC 那么频繁，并且做一次 Full GC 要比进行一次 Minor GC 的时间更长。
另外，标记-清除算法收集垃圾的时候会产生许多的内存碎片 ( 即不连续的内存空间 )，此后需要为较大的对象分配内存空间时，若无法找到足够的连续的内存空间，就会提前触发一次 GC 的收集动作。
```



备注：永久代从JDK8开始移出，新的叫做元数据。

备注2：关于JVM新生代、老年代：http://ju.outofmemory.cn/entry/346964

### 3. 谈一谈MinorGC和FullGC ⭐⭐⭐⭐

```
MinorGC：同2——新生代回收算法
FullGC：同2——老年代回收算法
```

附加问题：MinorGC和FullGC的触发条件

**Minor GC触发条件：**
**当Eden区满时，触发Minor GC。**

**Full GC触发条件：**

（1）System.gc()方法的调用【此方法的调用是建议JVM进行Full GC,虽然只是建议而非一定】

（2）老年代空间不足

（3）方法区空间不足

（4）通过Minor GC后进入老年代的平均大小大于老年代的可用内存

（5）由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小

### 4. GC垃圾回收器有哪些，区别。⭐⭐⭐⭐

```
(1)CMS(Concurrent Mark Sweep)是一款并发、使用标记-清除算法的gc。
CMS以获取最小停顿时间为目的。在一些对响应时间有很高要求的应用或网站中，用户程序不能有长时间的停顿，CMS 可以用于此场景。
TODO
```

### 5. 为什么要划分成年轻代和老年代⭐⭐⭐

分代的唯一理由就是**优化GC性能**

- 如果没有分代，所有的对象都在一块，GC的时要找到哪些对象是没用的，这样就会对堆的所有区域进行扫描。而我们的很多对象都是朝生夕死的。
- 如果分代的话，把新创建的对象放到某一地方，当GC的时先把这块存“朝生夕死”对象的区域进行回收，这样就会腾出很大的空间出来。

### 6. 年轻代—>年轻代为什么被划分成 eden、survivor 区域&年轻代为什么采用的是复制算法 ⭐⭐

> 这是一个非常有意思的问题，分析的过程也比较好玩

- 如果没有survivor区，那么很容易触发Major GC，影响程序效率
- 如果只有一个survivor区，那么容易在eden区域和survivor区域中产生内存碎片，影响内存分配

如果没有Survivor，Eden区每进行一次Minor GC，存活的对象就会被送到老年代。老年代很快被填满，触发Major GC（因为Major GC一般伴随着Minor GC，也可以看做触发了Full GC）。老年代的内存空间远大于新生代，进行一次Full GC消耗的时间比Minor GC长得多。你也许会问，执行时间长有什么坏处？频发的Full GC消耗的时间是非常可观的，这一点会影响大型程序的执行和响应速度，更不要说某些连接会因为超时发生连接错误了。

好，那我们来想想在没有Survivor的情况下，有没有什么解决办法，可以避免上述情况：

| 方案           | 优点                                        | 缺点                                                      |
| :------------- | :------------------------------------------ | :-------------------------------------------------------- |
| 增加老年代空间 | 更多存活对象才能填满老年代。降低Full GC频率 | 随着老年代空间加大，一旦发生Full GC，执行所需要的时间更长 |
| 减少老年代空间 | Full GC所需时间减少                         | 老年代很快被存活对象填满，Full GC频率增加                 |

显而易见，没有Survivor的话，上述两种解决方案都不能从根本上解决问题。

我们可以得到第一条结论：**Survivor的存在意义，就是减少被送到老年代的对象，进而减少Full GC的发生，Survivor的预筛选保证，只有经历16次Minor GC还能在新生代中存活的对象，才会被送到老年代。**

**设置两个Survivor区最大的好处就是解决了碎片化**，下面我们来分析一下。

为什么一个Survivor区不行？第一部分中，我们知道了必须设置Survivor区。假设现在只有一个survivor区，我们来模拟一下流程： 
刚刚新建的对象在Eden中，一旦Eden满了，触发一次Minor GC，Eden中的存活对象就会被移动到Survivor区。这样继续循环下去，下一次Eden满了的时候，问题来了，此时进行Minor GC，Eden和Survivor各有一些存活对象，如果此时把Eden区的存活对象硬放到Survivor区，很明显这两部分对象所占有的内存是不连续的，也就导致了内存**碎片化**。 

那么，顺理成章的，应该建立两块Survivor区，刚刚新建的对象在Eden中，经历一次Minor GC，Eden中的存活对象就会被移动到第一块survivor space S0，Eden被清空；等Eden区再满了，就再触发一次Minor GC，Eden和S0中的存活对象又会被复制送入第二块survivor space S1（**这个过程非常重要，因为这种复制算法保证了S1中来自S0和Eden两部分的存活对象占用连续的内存空间，避免了碎片化的发生**）。S0和Eden被清空，然后下一轮S0与S1交换角色，如此循环往复。如果对象的复制次数达到16次，该对象就会被送到老年代中。

### 7. 老年代—>老年代为什么采用的是标记清除、标记整理算法  ⭐⭐

老年代不使用复制算法的原因就是复制算法的缺点：

- 空间成本高，需要双倍空间
- 复制的时间成本高

### 8. 堆外内存—>什么是堆外内存，如何被回收 ⭐⭐⭐

```

```

### 9. StopTheWorld ⭐⭐⭐

关于JVM进阶知识：https://blog.csdn.net/sunhuaqiang1/column/info/15328

```

```

### 10.  静态变量和实例变量的区别  ⭐⭐⭐

需要结合Java类加载过程进行说明

```
一、实例变量
也叫对象变量、类成员变量；从属于类由类生成对象时，才分配存储空间，各对象间的实例变量互不干扰，能通过对象的引用来访问实例变量。但在Java多线程中，实例变量是多个线程共享资源，要注意同步访问时可能出现的问题。

二、类变量
也叫静态变量，是一种比较特殊的实例变量，用static关键字修饰；一个类的静态变量，所有由这类生成的对象都共用这个类变量，类装载时就分配存储空间。一个对象修改了变量，则所以对象中这个变量的值都会发生改变。
```

### 11. 类加载机制 ⭐⭐⭐⭐⭐

```

```

当我们的Java代码编译完成后，会生成对应的 class 文件。接着我们运行`java Demo`命令的时候，我们其实是启动了JVM 虚拟机执行 class 字节码文件的内容。而 JVM 虚拟机执行 class 字节码的过程可以分为七个阶段：**加载、验证、准备、解析、初始化、使用、卸载。**

#### 1.加载

```
加载阶段是类加载过程的第一个阶段。在这个阶段，JVM 的主要目的是将字节码从各个位置（网络、磁盘等）转化为二进制字节流加载到内存中，接着会为这个类在 JVM 的方法区创建一个对应的 Class 对象，这个 Class 对象就是这个类各种数据的访问入口。
```

#### 2.验证

当 JVM 加载完 Class 字节码文件并在方法区创建对应的 Class 对象之后，JVM 便会启动对该字节码流的校验，只有符合 JVM 字节码规范的文件才能被 JVM 正确执行。这个校验过程大致可以分为下面几个类型：

- **JVM规范校验。**JVM 会对字节流进行文件格式校验，判断其是否符合 JVM 规范，是否能被当前版本的虚拟机处理。例如：文件是否是以 `0x cafe bene`开头，主次版本号是否在当前虚拟机处理范围之内等。
- **代码逻辑校验。**JVM 会对代码组成的数据流和控制流进行校验，确保 JVM 运行该字节码文件后不会出现致命错误。例如一个方法要求传入 int 类型的参数，但是使用它的时候却传入了一个 String 类型的参数。一个方法要求返回 String 类型的结果，但是最后却没有返回结果。代码中引用了一个名为 Apple 的类，但是你实际上却没有定义 Apple 类。

#### 3.准备 ⭐

当完成字节码文件的校验之后，JVM 便会开始为类变量分配内存并初始化。这里需要注意两个关键点，即内存分配的对象以及初始化的类型。

- **内存分配的对象。**Java 中的变量有「类变量」和「类成员变量」两种类型，「类变量」指的是被 static 修饰的变量，而其他所有类型的变量都属于「类成员变量」。在准备阶段，**JVM 只会为「类变量」分配内存**，而不会为「类成员变量」分配内存。「类成员变量」的内存分配需要等到初始化阶段才开始。

例如下面的代码在准备阶段，只会为 factor 属性分配内存，而不会为 website 属性分配内存。

```java
public static int factor = 3;
public String website = "www.cnblogs.com/chanshuyi";
```

- **初始化的类型。**在准备阶段，JVM 会为类变量分配内存，并为其初始化。但是这里的初始化指的是为变量赋予 Java 语言中该数据类型的零值，而不是用户代码里初始化的值。

例如下面的代码在准备阶段之后，sector 的值将是 0，而不是 3。

```java
public static int sector = 3;
```

但如果一个变量是常量（被 static final 修饰）的话，那么在准备阶段，属性便会被赋予用户希望的值。例如下面的代码在准备阶段之后，number 的值将是 3，而不是 0。

```java
public static final int number = 3;
```

#### 4.解析

当通过准备阶段之后，JVM 针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符 7 类引用进行解析。这个阶段的主要任务是将其在常量池中的符号引用替换成直接其在内存中的直接引用。

其实这个阶段对于我们来说也是几乎透明的，了解一下就好。

#### 5.初始化  ⭐

到了初始化阶段，用户定义的 Java 程序代码才真正开始执行。在这个阶段，JVM 会根据语句执行顺序对类对象进行初始化，一般来说当 JVM 遇到下面 5 种情况的时候会触发初始化：

- 遇到 **new**、getstatic、putstatic、invokestatic 这四条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指令的最常见的Java代码场景是：使用new关键字实例化对象的时候、读取或设置一个类的静态字段（被final修饰、已在编译器把结果放入常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候。
- 使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。
- **当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。**
- **当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。**
- 当使用 JDK1.7 动态语言支持时，如果一个 java.lang.invoke.MethodHandle实例最后的解析结果 REF_getstatic,REF_putstatic,REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行初始化，则需要先出触发其初始化。

#### 5.使用

当 JVM 完成初始化阶段之后，JVM 便开始从入口方法开始执行用户的程序代码。这个阶段也只是了解一下就可以。

#### 6.卸载

当用户程序代码执行完毕后，JVM 便开始销毁创建的 Class 对象，最后负责运行的 JVM 也退出内存。这个阶段也只是了解一下就可以。

**其他：**

实际上Java代码编译成字节码之后，是没有构造方法的概念的，只有类初始化方法 和 对象初始化方法 。那么这两个方法是怎么来的呢？

- 类初始化方法。编译器会按照其出现顺序，收集类变量的赋值语句、静态代码块，最终组成类初始化方法。**类初始化方法一般在类初始化的时候执行。**

- 对象初始化方法。编译器会按照其出现顺序，收集成员变量的赋值语句、普通代码块，最后收集构造函数的代码，最终组成对象初始化方法。**对象初始化方法一般在实例化类对象的时候执行。**

类加载过程解析：https://www.cnblogs.com/chanshuyi/p/the_java_class_load_mechamism.html ，结合_01Common Book类进行解析

---



### 2. Java中堆和栈的区别。
### 3. 谈一谈GC回收算法。
### 4. MinorGC和FullGC区别。


### 6. MS GC 回收分为哪几个阶段，分别做了什么事情。
### 7. CMS 有哪些重要参数。
### 8. Concurrent Model Failure 和 ParNew promotion failed 什么情况下会发生。
### 9. CMS 的优缺点。
### 10. 有做过哪些 GC 调优。
### 11. 为什么要划分成年轻代和老年代。
### 12. 年轻代为什么被划分成 eden、survivor 区域。
### 13. 年轻代为什么采用的是复制算法。
### 14. 老年代为什么采用的是标记清除、标记整理算法。
### 15.什么情况下使用堆外内存，要注意些什么。
### 16. 堆外内存如何被回收。

## 多线程

(1)多线程的各种概念是相互交叉的，比如线程的状态转换和关键词（wait notify synchronized有关），又同时和操作系统中CPU的切换有关，要形成知识系统。

### 1. volatile关键词的作用。⭐⭐⭐⭐

```
被volatile修饰的共享变量，就会具有以下两个特性：
1. 保证了不同线程对该变量操作的内存可见性。
2. 禁止指令重排序。
```

这个要是说起来可就多了，我就从Java内存模型开始说起吧。Java虚拟机规范试图定义一个Java内存模型(JMM)，以屏蔽所有类型的硬件和操作系统内存访问差异，让Java程序在不同的平台上能够达到一致的内存访问效果。简单地说，由于CPU执行指令的速度很快，但是内存访问速度很慢，差异不是一个量级，所以搞处理器的那群大佬们又在CPU里加了好几层高速缓存。

在Java内存模型中，对上述优化进行了一波抽象。JMM规定所有的变量都在主内存中，类似于上面提到的普通内存，每个线程又包含自己的工作内存，为了便于理解可以看成CPU上的寄存器或者高速缓存。因此，线程的操作都是以工作内存为主，它们只能访问自己的工作内存，并且在工作之前和之后，该值被同步回主内存。

并发编程的三个特点：

（1）原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。

（2）可见性：指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。

（3）有序性：即程序执行的顺序按照代码的先后顺序执行。

### 2. Java里的线程有哪些状态,状态之间如何进行转换？⭐⭐⭐

```
Java线程的生命周期中，存在几种状态。在Thread类里有一个枚举类型State，定义了线程的几种状态，分别有：

NEW: 线程创建之后，但是还没有启动(not yet started)。这时候它的状态就是NEW

RUNNABLE: 正在Java虚拟机下跑任务的线程的状态。在RUNNABLE状态下的线程可能会处于等待状态， 因为它正在等待一些系统资源的释放，比如IO

BLOCKED: 阻塞状态，等待锁的释放，比如线程A进入了一个synchronized方法，线程B也想进入这个方法，但是这个方法的锁已经被线程A获取了，这个时候线程B就处于BLOCKED状态(比较常见)

WAITING: 等待状态，处于等待状态的线程是由于执行了3个方法中的任意方法。 1. Object的wait方法，并且没有使用timeout参数; 2. Thread的join方法，没有使用timeout参数 3. LockSupport的park方法。 处于waiting状态的线程会等待另外一个线程处理特殊的行为。 再举个例子，如果一个线程调用了一个对象的wait方法，那么这个线程就会处于waiting状态直到另外一个线程调用这个对象的notify或者notifyAll方法后才会解除这个状态

TIMED_WAITING: 有等待时间的等待状态，比如调用了以下几个方法中的任意方法，并且指定了等待时间，线程就会处于这个状态。 1. Thread.sleep方法 2. Object的wait方法，带有时间 3. Thread.join方法，带有时间 4. LockSupport的parkNanos方法，带有时间 5. LockSupport的parkUntil方法，带有时间

TERMINATED: 线程中止的状态，这个线程已经完整地执行了它的任务
```

![](pics/java_thread_status.png)

### 3. 乐观锁和悲观锁的区别。⭐⭐⭐⭐⭐

悲观锁：synchronized和ReentranLock

```
总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现。
```



乐观锁：版本控制机制和CAS算法

**CAS** 

应用场景：JUC.atomic包

```
compare and swap（比较与交换），是一种有名的无锁算法。无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization）。CAS算法涉及到三个操作数

需要读写的内存值 V
进行比较的值 A
拟写入的新值 B

当且仅当 V 的值等于 A时，CAS通过原子方式用新值B来更新V的值，否则不会执行任何操作（比较和替换是一个原子操作）。一般情况下是一个自旋操作，即不断的重试。
```

缺点：

```
CPU性能开销：如果一个线程不断尝试修改值，都没有成功，计算造成的开销
ABA问题：
如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然是A值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回A，那CAS操作就会误认为它从来没有被修改过。这个问题被称为CAS操作的 "ABA"问题。
```

synchronized和CAS乐观锁的比较：**单的来说CAS适用于写比较少的情况下（多读场景，冲突一般较少），synchronized适用于写比较多的情况下（多写场景，冲突一般较多）**

对于资源竞争较少（线程冲突较轻）的情况，使用synchronized同步锁进行线程阻塞和唤醒切换以及用户态内核态间的切换操作额外浪费消耗cpu资源；而CAS基于硬件实现，不需要进入内核，不需要切换线程，操作自旋几率较少，因此可以获得更高的性能。

对于资源竞争严重（线程冲突严重）的情况，CAS自旋的概率会比较大，从而浪费更多的CPU资源，效率低于synchronized。

### 4. JUC包（Java.util.Concurrent）⭐⭐⭐⭐⭐

```

```

#### 1. synchronized

```

```



#### 2. reentrantlock

```

```



#### 3. AbstractQueuedSynchronizer【AQS】

```

```



源码分析：https://www.javadoop.com/post/AbstractQueuedSynchronizer

#### 4. ConcurrentHashMap

```

```

#### 5.   CopyOnWriteArrayList





### 5. Java中有哪些锁？⭐⭐⭐⭐

美团技术文章：https://tech.meituan.com/2018/11/15/java-lock.html（Java中的锁）

- 按照特性有不同的划分规则，同一个锁可能会有多种特性，比如ReentrantLock是悲观锁、0非公平锁（默认）、可重入锁、独享锁。
- AQS的应用比较广泛 ![](pics/java_multi_thread_structure.jpg)

![](pics/java_lock_collection.png)

（1）自旋锁：

```
阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长。

在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复现场的花费可能会让系统得不偿失。如果物理机器有多个处理器，能够让两个或以上的线程同时并行执行，我们就可以让后面那个请求锁的线程不放弃CPU的执行时间，看看持有锁的线程是否很快就会释放锁。

而为了让当前线程“稍等一下”，我们需让当前线程进行自旋，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销。这就是自旋锁。
```

![](pics/java_lock_self_wait.png)

应用场景：CAS（java.util.concurrent.atomicInteger）重新尝试更新值的过程

（2）公平锁&非公平锁

```
公平锁是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁。公平锁的优点是等待锁的线程不会饿死。缺点是整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU唤醒阻塞线程的开销比非公平锁大。
```

应用场景：ReentrantLock默认是非公平锁，可以通过构造方法实现非公平锁。

（3）重入锁&非重入锁

```
可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提锁对象得是同一个对象或者class），不会因为之前已经获取过还没释放而阻塞。Java中ReentrantLock和synchronized都是可重入锁，可重入锁的一个优点是可一定程度避免死锁。
```

```java
public class Widget {
    public synchronized void doSomething() {
        System.out.println("方法1执行...");
        doOthers();
    }

    public synchronized void doOthers() {
        System.out.println("方法2执行...");
    }
}
```

（4）独享锁&共享锁

```
对于Java ReentrantLock而言，其是独享锁。但是对于Lock的另一个实现类ReadWriteLock，其读锁是共享锁，其写锁是独享锁。
　　 读锁的共享锁可保证并发读是非常高效的，读写，写读 ，写写的过程是互斥的。
　　 独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享。
```

### 6. 并发和并行的区别 ⭐⭐

- 并发:一个处理器同时处理多个任务。
- 并行:多个处理器或者是多核的处理器同时处理多个不同的任务.

前者是逻辑上的同时发生（simultaneous），而后者是物理上的同时发生。【是否使用多个处理器】

![](pics/concurrency_parrel.png)



----



### 3. Runnable和Thread的比较。

### 4. Thread类的start()和run()方法有啥区别。
### 5. Runnbale和Callable有啥不同。
### 6. 线程安全的定义是什么。Vector是线程安全类吗。
### 7. 谈一谈Java中的竞态条件。
### 8. Java中如何停止一个线程。

```

```



### 9. 一个线程运行时发生异常会怎么。
### 




https://tech.meituan.com/2018/11/15/java-lock.html——美团技术团队的锁的总结

### 12. 如何实现一个乐观锁。
### 13. AQS是如何唤醒下一个线程的。
### 14. ReentrantLock如何实现公平和非公平锁。
### 15. CountDownLatch和CyclicBarrier的区别。各自适用于什么场景。
### 16. 什么是ThreadLocal，以及使用时需要注意什么，比如内存泄漏。
### 17. 说一说往线程池中提交一个任务会发生什么。
### 18. 线程池几个参数如何设置。
### 19. 线程池的非核心线程什么时候会被释放。
### 20. 如何排查死锁。
### 21. 如何在两个线程间共享数据。
### 22. notify和notifyAll有什么区别。
### 23. 为什么wait，notify，notifyAll这些方法不在Thread类里面。
### 24. 什么是FutureTask。
### 25. interrupted和isInterrupted方法有啥区别。
### 26. 为什么wait和notify方法要在同步块中使用。
### 27. 为什么应该在循环中检查等待条件。
### 28. Java中的同步集合和并发集合有什么区别。
### 29. 什么是线程池，为什么要使用线程池。
### 30. 请你实现一个生产者——消费者模型。
### 31. Java里面的活锁和死锁有什么区别。
### 32. 如何检查一个线程是否持有锁。
### 33. 在Java中，如何获取线程堆栈。
### 34. 有三个线程t1,t2,t3，如何确保它们的执行顺序。
### 35. 谈一塔Semaphore类。
### 36. ConcurrentHashMap的并发度是什么。
### 37. 你往线程池中提交任务时候，如果线程队列已经满了，会发生什么。
### 38. submit()和execute()方法的区别。
### 39. Swing是线程安全的吗。
### 40. invokeAndWait和invokeLater有什么区别。
### 41. Swing API中哪些方法是线程安全的。
### 42. 如何创建Immutable对象。
### 43. ReadWriteLock类是什么。
### 44. 多线程中的忙循环。
### 45. 如何强制启动一个线程。
### 46. wait()和sleep()方法有啥不同。
### 47. 说出3条你遵循的多线程的最佳实践。
## I/O

### 1. IO模型有哪些，讲讲你理解的NIO，它和BIO，AIO的区别是啥。

### 2. 讲一下Reactor模型。

### 3. 同步阻塞、同步非阻塞、异步的区别。

### 4. select、poll、eopll 的区别。

## JDK8

函数式编程：

我们最常用的面向对象编程（Java）属于**命令式编程**（Imperative Programming）这种编程范式。常见的编程范式还有**逻辑式编程**（Logic Programming），**函数式编程**（Functional Programming）。

函数式编程作为一种编程范式，在科学领域，是一种编写计算机程序数据结构和元素的方式，它把计算过程当做是数学函数的求值，而避免更改状态和可变数据。

- 函数式编程带来的好处尤为明显。这种代码更多地表达了业务逻辑的意图，而不是它的实现机制。易读的代码也易于维护、更可靠、更不容易出错。【类似于框架的作用】

### 1. lambda表达式⭐⭐⭐⭐

使用Java 8 Lambda表达式可以实现更高的效率。通过使用具有多核的CPU，用户可以通过使用lambda并行处理集合来利用多核CPU。

```java
        Arrays.asList("a","v","e").forEach(e -> {
            System.out.println(e);
            System.out.println("---");
        });
```

### 2.  函数式接口⭐⭐

函数式接口(Functional Interface)就是一个有且仅有一个抽象方法，但是可以有多个非抽象方法的接口。

```java
@FunctionalInterface
interface  GreetingService{
    //只能有这一个抽象方法
    void sayMessage(String message);
}

public class _funcitonalInterface {

    public static void main(String[] args) {
        //代替匿名内部类
        GreetingService greetingService = message -> {
            System.out.println("get msg :" + message);
        };

        greetingService.sayMessage("gee");
    }
}
```

Consumer

Function

Predicate

### 3. Stream流操作 ⭐⭐⭐⭐

流支持并行操作，而迭代器，for循环都是串行操作，所以流在多核处理上有强大优势。

主要是对于集合类的操作：stream是对集合对象功能的增强，它专注于对集合对象进行各种非常便利、高效的聚合操作，或者大批量数据操作。

应用场景：只要给出需要对其包含的元素执行什么操作，比如 “过滤掉长度大于 10 的字符串”、“获取每个字符串的首字母”等，Stream 会隐式地在内部进行遍历，做出相应的数据转换。

```java
        List<Person> collect = res
                .stream()
                .filter(person -> {
                    if("男".equals(person.getSex()) && person.getAge() < 22)
                        return true;
                    return false;
                })
                .collect(Collectors.toList());

        System.out.println(collect);
```

https://www.jianshu.com/p/9fe8632d0bc2 关于Stream的实际应用

主要是Filter和Map的使用


# 操作系统
### 1. 进程和线程的区别是什么 ⭐⭐⭐⭐⭐

(1)CPU资源开销

(2)通信方式

(3)是否有独立的地址空间

```
进程是资源分配的最小单位，线程是程序执行的最小单位。

进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。而线程是共享进程中的数据的，使用相同的地址空间，因此CPU切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多。

线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式（IPC)进行。不过如何处理好同步与互斥是编写多线程程序的难点。

但是多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。
```

**附加问题：协程是什么**

**协程，英文Coroutines，是一种比线程更加轻量级的存在。**正如一个进程可以拥有多个线程一样，一个线程也可以拥有多个协程。

最重要的是，协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行）。

这样带来的好处就是性能得到了很大的提升，不会像线程切换那样消耗资源。

由于Java的原生语法中并没有实现协程。

![](pics/Coroutines.png)







### 2. 什么是操作系统的用户态，什么是操作系统的内核态？之间如何转换⭐⭐⭐⭐⭐

(1)为什么要区分用户态和内核态？

```
在计算机系统中，通常运行着两类程序：系统程序和应用程序，为了保证系统程序不被应用程序有意或无意地破坏，为计算机设置了两种状态：

系统态(也称为管态或核心态)，操作系统在系统态运行——运行操作系统程序
用户态(也称为目态)，应用程序只能在用户态运行——运行用户程序
在实际运行过程中，处理机会在系统态和用户态间切换。相应地，现代多数操作系统将 CPU 的指令集分为特权指令和非特权指令两类。

1) 特权指令——在系统态时运行的指令
对内存空间的访问范围基本不受限制，不仅能访问用户存储空间，也能访问系统存储空间，
特权指令只允许操作系统使用，不允许应用程序使用，否则会引起系统混乱。

2) 非特权指令——在用户态时运行的指令
一般应用程序所使用的都是非特权指令，它只能完成一般性的操作和任务，不能对系统中的硬件和软件直接进行访问，其对内存的访问范围也局限于用户空间。
```

- **用户态**切换到**内核态**的**唯一**途径——>**中断/异常/陷入**
- **内核态**切换到**用户态**的途径——>设置程序状态字

**注意一条特殊的指令——陷入指令（又称为访管指令**，因为内核态也被称为管理态，访管就是访问管理态）该指令给用户提供接口，用于调用操作系统的服务。

### 3. 什么是中断 ⭐⭐⭐⭐

还是老问题，为什么在操作系统中设计了中断的概念？为了提高并发执行的效率。

```
CPU中断正在运行的程序，转到处理中断事件程序
```

![](pics/system_interrupted.png)

关于中断概念的解释：http://www.kerneltravel.net/journal/viii/01.htm

### 4. 什么是系统调用 ⭐⭐⭐⭐

定义：系统调用是linux内核中设置了一组用于实现系统功能的子程序。（位于操作系统内核的函数）

```
系统调用和普通库函数调用非常相似，只是系统调用由操作系统核心提供，运行于核心态，而普通的函数调用由函数库或用户自己提供，运行于用户态。
```

### 5. 什么死锁，死锁的条件有哪些？⭐⭐⭐⭐

```
由于系统中存在一些不可剥夺资源，而当两个或两个以上的进程占有自身资源，并请求对方资源时，会导致每个进程都无法向前推进，这就是死锁。死锁产生的必要条件有四个：互斥条件、不可剥夺条件、请求与保持条件、循环等待条件。

互斥条件指进程要求分配的资源是排他性的，即最多只能同时给一个进程使用。
不剥夺条件是指进程在使用资源完毕之前，资源不能被强行夺走。
请求并保持条件是指进程占有自身本来拥有的资源并要求其他资源。
循环等待条件是指存在一种进程资源的循环等待链。
```

### 6. 进程之间有哪些通信方式 ⭐⭐⭐⭐⭐

(1)管道

(2)消息队列

(3)共享内存

```
1.管道（pipe）及有名管道（named pipe）：
匿名管道( pipe )：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。

通过匿名管道实现进程间通信的步骤如下：
父进程创建管道，得到两个⽂件描述符指向管道的两端
父进程fork出子进程，⼦进程也有两个⽂件描述符指向同⼀管道。
父进程关闭fd[0],子进程关闭fd[1]，即⽗进程关闭管道读端,⼦进程关闭管道写端（因为管道只支持单向通信）。⽗进程可以往管道⾥写,⼦进程可以从管道⾥读,管道是⽤环形队列实现的,数据从写端流⼊从读端流出,这样就实现了进程间通信。

2.信号（signal）：
信号是在软件层次上对中断机制的一种模拟，它是比较复杂的通信方式，用于通知进程有某事件发生，一个进程收到一个信号与处理器收到一个中断请求效果上可以说是一致的。

3.消息队列（message queue）：
消息队列是消息的链接表，它克服了上两种通信方式中信号量有限的缺点，具有写权限得进程可以按照一定得规则向消息队列中添加新信息；对消息队列有读权限得进程则可以从消息队列中读取信息。

4.共享内存（shared memory）：
可以说这是最有用的进程间通信方式。它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。

5.信号量（semaphore）：
主要作为进程之间及同一种进程的不同线程之间得同步和互斥手段。

6.套接字（socket）；
这是一种更为一般得进程间通信机制，它可用于网络中不同机器之间的进程间通信，应用非常广泛。
```

### 7. 什么是缺页中断？⭐⭐⭐⭐⭐

```
在请求分页系统中，可以通过查询页表中的状态位来确定所要访问的页面是否存在于内存中。每当所要访问的页面不在内存时，会产生一次缺页中断，此时操作系统会根据页表中的外存地址在外存中找到所缺的一页，将其调入内存。 
　　缺页本身是一种中断，与一般的中断一样，需要经过4个处理步骤： 
　　1. 保护CPU现场 
　　2. 分析中断原因 
　　3. 转入缺页中断处理程序进行处理 
　　4. 恢复CPU现场，继续执行 
```



关于缺页中断的实践：https://liam.page/2017/09/01/page-fault/

### 8. 枚举一下常见的（缺页中断）页面置换算法⭐⭐⭐

**FIFO算法**

**LRU算法**

```
置换最近一段时间以来最长时间未访问过的页面。根据程序局部性原理，刚被访问的页面，可能马上又要被访问；而较长时间内没有被访问的页面，可能最近不会被访问。 
```

LRU算法计算的精髓在于根据（1）当前物理块中的内容 （2）前面计算序列访问了哪些物理块

### 9. 谈一谈fork()函数 ⭐⭐⭐⭐

```
在fork函数执行完毕后，如果创建新进程成功，则出现两个进程，一个是子进程，一个是父进程。在子进程中，fork函数返回0，在父进程中，fork返回新创建子进程的进程ID。我们可以通过fork返回的值来判断当前进程是子进程还是父进程。fork调用的一个奇妙之处就是它仅仅被调用一次，却能够返回两次，它可能有三种不同的返回值：
    1）在父进程中，fork返回新创建子进程的进程ID；
    2）在子进程中，fork返回0；
    3）如果出现错误，fork返回一个负值；
```

### 10. 页式内存管理中，怎样从逻辑地址，计算物理地址？⭐⭐

```
分页机制的思想是:通过映射，可以使连续的线性地址与物理地址相关联，逻辑上连续的线性地址对应的物理地址可以不连续。 分页的作用 - 将线性地址转换为物理地址 - 用大小相同的页替换大小不同的段。

逻辑地址 = 页号 + 页内偏移量
取到页号之后，查询页表，得到块号，然后在内存中通过块号&页内偏移量得到最终的物理地址
```

![](pics/memory_management_leaf.png)

### 11. linux终端按下Ctrl+C发生了什么 ⭐⭐⭐

```
ctrl-c: ( kill foreground process ) 发送 SIGINT 信号给前台进程组中的所有进程，强制终止程序的执行；
ctrl-z: ( suspend foreground process ) 发送 SIGTSTP 信号给前台进程组中的所有进程，常用于挂起一个进程，而并 非结束进程，用户可以使用使用fg/bg操作恢复执行前台或后台的进程。
```

根据 `setpgrp` manual page 的说法，按下 `Ctrl-c` 后（主要是操作系统进程通信-信号机制）:

- 终端产生 `SIGINT` 信号
- 前台进程组中的所有进程都会接收到 `SIGINT` 信号然后退出(默认动作)
- shell通过调用 `waitpid` 清理进程表中子进程信息

### 12. 段氏内存管理，和页式内存管理的区别  ⭐⭐⭐

```

```



### 13. 编程实现一个LRU算法  ⭐⭐⭐⭐⭐

```

```

### 14. 进度调度算法 ⭐⭐⭐⭐

> 注意和页面调度算法区别开来

```

```













---



### 2. 什么是进程同步。
### 3. 进程间的通信方式有哪些。
### 4. 什么是上下文切换。
### 5. 进程有哪些状态， 如何转换。
### 6. 线程有哪些状态，如何转换。
### 7. 进程调度算法。
### 8. 死锁的条件，如何处理死锁。
### 9. 分析一个C程序从开始运行到结束的完整过程。
### 10. 什么是虚拟内存，优缺点。
### 11. 页式内存管理和段式内存管理的区别。
### 12. 页面置换算法有哪些，为什么要进行页面置换。
### 13. 实现一个LRU算法（经典）
### 14. 

### 15. 什么是系统调用。⭐⭐⭐⭐

```

```



### 16. Linux下启动的第一个进程是什么。
### 17. fork函数的作用，返回值是什么。
### 18. 系统调用和库函数的区别。
### 19. 编译性语言和解释性语言的区别
```
解释性语言的程序不要编译，省了道工序，解释性语言在运行程序的时候才翻译，比如解释性Java语言，专门有一个解释器可以直接执行Java程序,每一个语句都是执行的时候才能翻译。这样解释性语言每执行一次要翻译一次，效率表较低。

编译型就是编译的时候直接编译成机器可以执行的（.exe .dll .ocx）,编译和执行是分开的，但是不能跨平台。例如Delphi,C++,ASM,C是直接变异成exe文件并且自带条件编译功能。比如exe文件，以后要运行的话就不用重新编译了，直接使用编译的结果就行了（exe文件），因为翻译只做了一次，运行的时不要翻译，所以编译型语言的程序执行效率高。

编译性语言运行速度更快
```




# 计算机网络
```
### 1. 谈一谈OSI七层模型和TCP/IP五层模型。

​```

​```



### 2. IP地址的分类。

### 3. ARP协议的工作原理。

### 4. 在浏览器中输入网址之后执行的全部过程（经典）

### 5. TCP对应有哪些协议，UDP对应有哪些协议。

### 6. DNS协议的作用。

### 7. NAT协议的作用。

### 8. 子网掩码的作用。
```





---



### 1.TCP和UDP协议的区别。 ⭐⭐⭐

```
1、TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接
2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付
3、TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的
  UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）
4、每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信
5、TCP首部开销20字节;UDP的首部开销小，只有8个字节
6、TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道
```

### 2.  讲一下TCP的三次握手和四次挥手过程。 ⭐⭐⭐⭐⭐

三次握手和四次挥手过程都涉及到TCP报文的组成字段，特别是序列号seq、确认号ack，以及标记位（SIN ACK FIN）

![](pics/tcp three-way handshake.png)

```
(1)A向B发出连接请求报文段，其首部中的SYN=1，并选择序号seq=x，表明传送数据时的第一个数据字节的序号是x
(2)B收到连接请求后，如同意，则发回确认，其中SYN=1，ACK=1，确认号ack=x+1，自己选择的序号seq=y
(3)A收到后向B给出确认，其ACK=1，确认号ack=y+1
```

![](pics/tcp four-way say-goodbye.png)

```
1）客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。
2）服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。
3）客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。
4）服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。
5）客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。
6）服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。
```

（1）为什么连接的时候是三次握手，关闭的时候却是四次握手？

答：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。

（2）为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？

答：虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。

另外一种解释：Client在发送完最后一个ACK报文段后，再经过时间2MSL，就可以使本连接持续的时间内所产生的所有报文段，都从网络中消失。这样就可以使下一个新的连接中不会出现这种旧的连接请求报文段。

### 12. 为什么是三次握手，假如是两次握手呢。⭐⭐⭐

为什么不是两次握手，主要是针对第二次握手，Server发送的请求没有到Client,Client进入一直等待状态，Server认为连接已经建立，然后进入等待接收报文的状态，造成死锁。

```
第一次握手后，S可以确认自己收报文与C发报文的功能都正常，而C呢，它什么都不能确认。
第二次握手后，C可以确认自己的收发报文与S的收发报文功能都正常，也就是认为连接已建立。
那么第三次呢，S也可以确认双方能够正常通信。

假想一下，如果我们去掉了第三次呢？ 因为我们不进行第三次握手，所以在S对C的请求进行回应(第二次握手)后，就会理所当然的认为连接已建立，而如果C并没有收到S的回应呢？此时，C仍认为连接未建立，S会对已建立的连接保存必要的资源，如果大量的这种情况，S会崩溃。
```

一种官方的解释：

谢希仁版《计算机网络》中的例子是这样的，“已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。”

### 3.  TCP如何保证传输数据的可靠性。⭐⭐⭐⭐

#### 1. 滑动窗口



#### 2. 超时重传



#### 3. 拥塞原理





### 4. http是有状态还是无状态？ TCP是有状态还是无状态？ ⭐⭐⭐

> http为什么要设计成无状态的
>
> tcp为什么是有状态的？可以结合三次握手和四次挥手来说明

```
HTTP无状态协议，是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。

TCP协议是一种有状态协议,因为它是什么,而不是因为它是通过IP使用的,或者因为HTTP构建在它之上. TCP以窗口大小的形式维护状态(端点告知彼此准备好接收多少数据)和数据包顺序(端点必须在从另一个接收数据包时彼此确认).这个状态(另一个人可以接收多少字节,以及他是否接收到最后一个数据包)允许TCP甚至在固有的非可靠协议上是可靠的.因此,TCP是一种有状态协议,因为它需要状态才有用
```

### 5. HTTP协议常用的状态码。⭐⭐

```

```

### 6. HTTP POST和GET方法区别 ⭐⭐⭐

直接分析HTTP报文，以及报文常见内容解析

```

```







### 7. HTTP和HTTPS的区别。⭐⭐⭐⭐

```
HTTPS和HTTP的区别主要如下：

1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。

2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。

3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。

4、http的连接很简单，是无状态的；HTTPS协议是由SSL（Secure Sockets Layer）+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。
```

### 8. HTTPS加密原理 ⭐⭐⭐

#### 1. 非对称加密算法

1.A要向B发送信息，A和B都要产生一对用于加密和解密的公钥和私钥。

2.A的私钥保密，A的公钥告诉B；B的私钥保密，B的公钥告诉A。

3.A要给B发送信息时，A用B的公钥加密信息，因为A知道B的公钥。

4.A将这个消息发给B（已经用B的公钥加密消息）。

5.B收到这个消息后，B用自己的私钥解密A的消息。其他所有收到这个报文的人都无法解密，因为只有B才有B的私钥。

![](pics/encryption.png)



```
非对称加密算法需要两个密钥：公开密钥（publickey）和私有密钥（privatekey）。公开密钥与私有密钥是一对。
如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密。
被私钥加密过的密文只能被公钥解密，过程如下：
明文 + 加密算法 + 私钥 => 密文， 密文 + 解密算法 + 公钥 => 明文
因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。

私钥保密，公钥公开。
```

#### 2. HTTPS

![](pics/https.png)



```
一个HTTPS请求实际上包含了两次HTTP传输，可以细分为8步。
1.客户端向服务器发起HTTPS请求，连接到服务器的443端口
2.服务器端有一个密钥对，即公钥和私钥，是用来进行非对称加密使用的，服务器端保存着私钥，不能将其泄露，公钥可以发送给任何人。
3.服务器将自己的公钥发送给客户端。
4.客户端收到服务器端的公钥之后，会对公钥进行检查，验证其合法性，如果发现发现公钥有问题，那么HTTPS传输就无法继续。严格的说，这里应该是验证服务器发送的数字证书的合法性，关于客户端如何验证数字证书的合法性，下文会进行说明。如果公钥合格，那么客户端会生成一个随机值，这个随机值就是用于进行对称加密的密钥，我们将该密钥称之为client key，即客户端密钥，这样在概念上和服务器端的密钥容易进行区分。然后用服务器的公钥对客户端密钥进行非对称加密，这样客户端密钥就变成密文了，至此，HTTPS中的第一次HTTP请求结束。
5.客户端会发起HTTPS中的第二个HTTP请求，将加密之后的客户端密钥发送给服务器。
6.服务器接收到客户端发来的密文之后，会用自己的私钥对其进行非对称解密，解密之后的明文就是客户端密钥，然后用客户端密钥对数据进行对称加密，这样数据就变成了密文。
7.然后服务器将加密后的密文发送给客户端。
8.客户端收到服务器发送来的密文，用客户端密钥对其进行对称解密，得到服务器发送的数据。这样HTTPS中的第二个HTTP请求结束，整个HTTPS传输完成。
```

**总结：**

HTTPS为了兼顾安全与效率，同时使用了对称加密和非对称加密。数据是被对称加密传输的，对称加密过程需要客户端的一个密钥，为了确保能把该密钥安全传输到服务器端，采用非对称加密对该密钥进行加密传输，总的来说，**对数据进行对称加密，对称加密所要使用的密钥通过非对称加密传输**。

### 9. IP地址如何划分 ⭐⭐⭐

![](pics/ip_address.png)

IP公网地址和私网地址?

**公网IP地址**
公有地址分配和管理由Inter NIC（Internet Network Information Center 因特网信息中心）负责。各级ISP使用的公网地址都需要向Inter NIC提出申请，有Inter NIC统一发放，这样就能确保地址块不冲突。

**私网IP地址**
创建IP寻址方案的人也创建了私网IP地址。这些地址可以被用于私有网络，在Internet没有这些IP地址，Internet上的路由器也没有到私有网络的路由表。

- A类：10.0.0.0 255.0.0.0，保留了1个A类网络。
- B类：172.16.0.0 255.255.0.0～172.31.0.0 255.255.0.0，保留了16个B类网络。
- C类：192.168.0.0 255.255.255.0～192.168.255.0 255.255.255.0，保留了256个C类网络。

PS：私网地址访问Internet需要做NAT或PAT网络地址转换

![](pics/ip_gateway.png)

**备注：NAT是什么？**

NAT是 Network Address Translation 网络地址转换的缩写。 
NAT是将私有IP地址通过边界路由转换成外网IP地址，在边界路由的NAT地址转换表记录下这个转换映射记录，当外部数据返回时，路由使用NAT技术查询NAT转换表，再将目标地址替换成内网用户IP地址。 

**PAT(port address Translation，端口地址转换，也叫端口地址复用)**

这是最常用的NAT技术，也是IPv4能够维持到今天的最重要的原因之一，它提供了一种多对一的方式，对多个内网IP地址，边界路由可以给他们分配一个外网IP，利用这个外网IP的不同端口和外部进行通信。 

![](pics/nat.png)

**附加问题：为什么需要使用子网掩码**  

虽然我们说子网掩码可以分离出 *IP* 地址中的网络部分与主机部分，可大家还是会有疑问，比如为什么要区分网络地址与主机地址？区分以后又怎样呢？那么好，让我们再详细的讲一下吧！  

在使用 *TCP/IP* 协议的两台计算机之间进行通信时，我们通过将本机的子网掩码与接受方主机的 *IP* 地址进行 *'* 与 *'* 运算，即可得到目标主机所在的网络号，又由于每台主机在配置 *TCP/IP* 协议时都设置了一个本机 *IP* 地址与子网掩码，所以可以知道本机所在的网络号。

通过比较这两个网络号，就可以知道接受方主机是否在本网络上。如果网络号相同，表明接受方在本网络上，那么可以通过相关的协议把数据包直接发送到目标主机；如果网络号不同，表明目标主机在远程网络上，那么数据包将会发送给本网络上的路由器，由路由器将数据包发送到其他网络，直至到达目的地。在这个过程中你可以看到，子网掩码是不可或缺的！

**计算方式**

*1.* 将 *IP* 地址与子网掩码转换成二进制；

*2.* 将二进制形式的 *IP* 地址与子网掩码做 *'* 与 *'* 运算，将答案化为十进制便得到网络地址；

*3.* 将二进制形式的子网掩码取 *'* 反 *'* ；

*4.* 将取 *'* 反 *'* 后的子网掩码与 *IP* 地址做 *'* 与 *'* 运算，将答案化为十进制便得到主机地址。

下面我们用一个例子给大家演示：

假设有一个 *I P* 地址： *192.168.0.1*

子网掩码为： *255.255.255.0*

化为二进制为： *I P* 地址 *11000000.10101000.00000000.00000001*

子网掩码 *11111111.11111111.11111111.00000000*

将两者做 *'* 与 *'* 运算得： *11000000.10101000.00000000.00000000*

将其化为十进制得： *192.168.0.0*

这便是上面 *IP* 的网络地址，主机地址以此类推。

**小技巧：由于观察到上面的子网掩码为 C** **类地址的默认子网掩码（至于为什么，可看后面的子网掩码分类就明白了），便可直接看出网络地址为 IP** **地址的前三部分，即前三个字节，主机地址为最后一部分。**

### 10. DNS解析过程  ⭐⭐

```
1. 查询LocalDNS
2. 查询根域名服务器(.)，得到顶级域名服务器地址
3. 查询顶级域名服务器(.com)，得到二级域名服务器地址
4. 查询二级域名服务器(baidu.com)，得到权威服务器地址
5. 查询权威服务器(www.baidu.com)，得到IP地址
```

![](pics/dns.png)

### 9. 抓包实践

```cmd
# Mac配置Charles

```















































---



### 15. HTTP协议的特点。
### 16. HTTP中GET和POST的区别。
### 17. HTTPS的原理

### 18. 什么是对称加密，什么是非对称加密。
### 19. 长连接和短连接。
### 
### 
### 
### 
### 
### 
### 
### 

# 数据结构
### 1. 数组和链表数据结构描述，各自的时间复杂度。
### 
###
### 



## MySQL

### 1. MySQL的查询优化⭐⭐⭐

```
TODO
使用explain语句查看type是否是index以及其他使用了索引的类型
```



### 2. MySQL的索引结构 ⭐⭐⭐⭐⭐

MySQL数据库索引使用B+树：

B+树的特点：B+树是应文件系统所需而产生的一种B树的变形树（文件的目录一级一级索引，只有最底层的叶子节点（文件）保存数据）非叶子节点只保存索引，不保存实际的数据，数据都保存在叶子节点中。

![](pics/mysql_b+tree.png)

浅蓝色的块我们称之为一个**磁盘块**，可以看到**每个磁盘块包含几个数据项（深蓝色所示）和指针（黄色所示）**，如磁盘块1包含数据项17和35，包含指针P1、P2、P3，P1表示小于17的磁盘块，P2表示在17和35之间的磁盘块，P3表示大于35的磁盘块。真实的数据存在于叶子节点即3、5、9、10、13、15、28、29、36、60、75、79、90、99。非叶子节点只不存储真实的数据，只存储指引搜索方向的数据项，如17、35并不真实存在于数据表中。

**查询过程**：

如图所示，如果要查找数据项29，那么首先会把磁盘块1由磁盘加载到内存，此时发生一次IO，在内存中用二分查找确定29在17和35之间，锁定磁盘块1的P2指针，内存时间因为非常短（相比磁盘的IO）可以忽略不计，通过磁盘块1的P2指针的磁盘地址把磁盘块3由磁盘加载到内存，发生第二次IO，29在26和30之间，锁定磁盘块3的P2指针，通过指针加载磁盘块8到内存，发生第三次IO，同时内存中做二分查找找到29，结束查询，总计三次IO。真实的情况是，3层的b+树可以表示上百万的数据，如果上百万的数据查找只需要三次IO，性能提高将是巨大的，如果没有索引，每个数据项都要发生一次IO，那么总共需要百万次的IO，显然成本非常非常高。

**相对于二叉查找树、AVL树，为什么要使用B/B+树:**

```
我们在MySQL中的数据一般是放在磁盘中的，读取数据的时候肯定会有访问磁盘的操作，磁盘中有两个机械运动的部分，分别是盘片旋转和磁臂移动。盘片旋转就是我们市面上所提到的多少转每分钟，而磁盘移动则是在盘片旋转到指定位置以后，移动磁臂后开始进行数据的读写。那么这就存在一个定位到磁盘中的块的过程，而定位是磁盘的存取中花费时间比较大的一块，毕竟机械运动花费的时候要远远大于电子运动的时间。当大规模数据存储到磁盘中的时候，显然定位是一个非常花费时间的过程，但是我们可以通过B树进行优化，提高磁盘读取时定位的效率。
```

**相对于B树，为什么要使用B+树：**

1、 B+树的磁盘读写代价更低：B+树的内部节点并没有指向关键字具体信息的指针，因此其内部节点相对B树更小，如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多，一次性读入内存的需要查找的关键字也就越多，相对IO读写次数就降低了。

2、B+树的查询效率更加稳定：由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。

### 3. 数据库的事务⭐⭐⭐⭐⭐

事务是对数据库中一系列操作进行统一的回滚或者提交的操作，主要用来保证数据的完整性和一致性。

```
原子性（Atomicity）:原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。
一致性（Consistency）:事务开始前和结束后，数据库的完整性约束没有被破坏。比如A向B转账，不可能A扣了钱，B却没收到。
隔离性（Isolation）:隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转账。
持久性（Durability）:持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。
```

**事务的并发问题：**

```
1、脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据

2、不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果因此本事务先后两次读到的数据结果会不一致。

3、幻读：幻读解决了不重复读，保证了同一个事务里，查询的结果都是事务开始时的状态（一致性）。
例如：事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作 这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。 而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有跟没有修改一样，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。

小结：不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表。
```

**事务的隔离级别：**

```
读未提交：另一个事务修改了数据，但尚未提交，而本事务中的SELECT会读到这些未被提交的数据脏读

读已提交：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果因此本事务先后两次读到的数据结果会不一致。

可重复读：在同一个事务里，SELECT的结果是事务开始时时间点的状态，因此，同样的SELECT操作读到的结果会是一致的。但是，会有幻读现象

串行化：最高的隔离级别，在这个隔离级别下，不会产生任何异常。并发的事务，就像事务是在一个个按照顺序执行一样
```

（1）设置read uncommited的时候可以发现脏读[事务A读到了事务B没有提交的数据]

（2）设置read commited的时候可以解决上述问题，但是在A中同一个事务，读到了不同的数据，导致了[不可重复读]

（3）设置repeatable read的时候，如果在A中插入一条数据，提交事务之后，在B中无法观察到该数据，所以产生了[幻读]

MySQL的默认事务隔离级别：可重复读

> 数据库事务的并发问题以及隔离级别容易忘记，对于这种知识，需要多动手实践，总结背后的connection ：https://www.jianshu.com/p/4e3edbedb9a8

### 4. 索引的最左匹配原则 ⭐⭐⭐⭐⭐

预备知识——explain查询结果type解释

```
index：这种类型表示是mysql会对整个该索引进行扫描。要想用到这种类型的索引，对这个索引并无特别要求，只要是索引，或者某个复合索引的一部分，mysql都可能会采用index类型的方式扫描。但是呢，缺点是效率不高，mysql会从索引中的第一个数据一个个的查找到最后一个数据，直到找到符合判断条件的某个索引。

ref：这种类型表示mysql会根据特定的算法快速查找到某个符合条件的索引，而不是会对索引中每一个数据都进行一 一的扫描判断，也就是所谓你平常理解的使用索引查询会更快的取出数据。而要想实现这种查找，索引却是有要求的，要实现这种能快速查找的算法，索引就要满足特定的数据结构。简单说，也就是索引字段的数据必须是有序的，才能实现这种类型的查找，才能利用到索引。
```

```sql
CREATE TABLE `user2` (
  `userid` int(11) NOT NULL AUTO_INCREMENT,
  `username` varchar(20) NOT NULL DEFAULT '',
  `password` varchar(20) NOT NULL DEFAULT '',
  `usertype` varchar(20) NOT NULL DEFAULT '',
  PRIMARY KEY (`userid`),
  KEY `a_b_c_index` (`username`,`password`,`usertype`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;
```

`a_b_c_index`实际建立了(username)、（username,password）、（username、password、usertype）三个索引

```
# 不使用索引
explain select * from user2 where password = '1';
# 使用索引
explain select * from user2 where username = '1' and password = '1';
# 使用索引-即使是乱序
explain select * from user2 where password = '1' and username = '1';
```

TODO：最左前缀匹配具体是怎么实现查找的？最左前缀匹配用了B+树的哪些特性？



# Web开发

## 基础知识

### 1. Cookie和Session区别，使用方式⭐⭐⭐⭐⭐

```
0. Cookie和Session的出现是为了解决什么问题——HTTP协议
1. Cookie和Session都是一种会话机制
2. 保存的位置不同：Cookie保存在客户端，Session保存在服务器
3. Java中的Cookie
	3.1 cookie = new Cookie(String name,String value) //设置Cookie
4. Java中的Session
	4.1 HttpSession session = httpServletRequest.getSession() //创建|获取Session
	4.2 String username = (String) session.getAttribute(String name) //获取Sesion某个属性
5. Cookie保存在本地，相对不安全，Session相对安全	
```

关于sessionid

那么Session在何时创建呢？当然还是在服务器端程序运行的过程中创建的，不同语言实现的应用程序有不同创建Session的方法，而在Java中是通过调用HttpServletRequest的getSession方法（使用true作为参数）创建的。在创建了Session的同时，服务器会为该Session生成唯一的Session id，而这个Session id在随后的请求中会被用来重新获得已经创建的Session；在Session被创建之后，就可以调用Session相关的方法往Session中增加内容了，而这些内容只会保存在服务器中，**发到客户端的只有Session id；当客户端再次发送请求的时候，会将这个Session id带上，服务器接受到请求之后就会依据Session id找到相应的Session，从而再次使用之。**

**Session的生命周期：**

**创建**：sessionid第一次产生是在直到某server端程序调用 HttpServletRequest.getSession(true)这样的语句时才被创建。

**删除**：

- 服务器会把长时间没有活动的Session从服务器内存中清除，此时Session便失效。可以设置session超时时间

- 程序调用HttpSession.invalidate()

### 2. Servlet的生命周期 ⭐⭐⭐

```
init() 方法
init 方法被设计成只调用一次。它在第一次创建 Servlet 时被调用，用于 Servlet的初始化，初始化的数据，可以在整个生命周期中使用。

service() 方法
service() 方法是执行实际任务的主要方法。 Servlet 容器（Tomcat、Jetty等）调用 service() 方法来处理来自客户端（浏览器）的请求，并把相应结果返回给客户端。
每次 Servlet 容器接收到一个 Http 请求， Servlet 容器会产生一个新的线程并调用 Servlet实例的 service 方法。 service 方法会检查 HTTP 请求类型（GET、POST、PUT、DELETE 等），并在适当的时候调用 doGet、doPost、doPut、doDelete 方法。所以，在编码请求处理逻辑的时候，我们只需要关注 doGet()、或doPost()的具体实现即可。

destroy() 方法
destroy() 方法也只会被调用一次，在 Servlet 生命周期结束时调用。destroy() 方法主要用来清扫“战场”，执行如关闭数据库连接、释放资源等行为。
调用 destroy 方法之后，servlet 对象被标记为垃圾回收，等待 JVM 的垃圾回收器进行处理。
```

![](pics/servlet_lifetime.png)

### 3. 客户端禁用cookie怎么办？ 你说的实现方式安全吗？ ⭐⭐⭐

> 比较偏重实践的一个问题

```
session的实现方式有两种第一种：通过cookies实现。如果浏览器支持cookies，创建session的时候会把sessionID放在cookies里面；
第二种：通过重写URL。如果浏览器不支持cookies，可以自己编程使用URL重写的方式实现session（访问页面的时候在地址栏里面，URL后会跟上sessionID）。
```





## SPRING
为什么要使用Spring，为了解决什么问题。

相对于传统的HttpServlet，框架存在的意义：让使用者只关心核心业务的开发，框架帮你屏蔽原有技术跟业务开发无关的各类技术问题。

### 1. IoC是什么 ⭐⭐⭐⭐⭐

```
IoC(Inversion of Controll) / DI(Dependency Injection) 控制反转/依赖注入，是一种编程思想。
1. 编码流程：
	（1）applicationContext.xml文件——通过bean标签，通过工厂getBean()方法
	（2）applicationContext接口，实例化ClassPathXmlApplicationContext
	（3）获取对象实例
```

![](pics/spring ioc重要类.png)

SpringIOC加载全过程

https://blog.csdn.net/qq_34203492/article/details/83865450 

https://www.cnblogs.com/stateis0/p/9779011.htm

#### IoC底层实现原理

反射

### 2. AOP是什么，是为了解决什么问题。 ⭐⭐⭐⭐⭐

OOP（面向对象的方式）：比如中间是打印日志的逻辑

![](pics/aop_1.png)

AOP（面向切面的方式）：不会改变原有的代码逻辑

![](pics/aop_2.png)

关于AOP中的一些概念：

```
Aspect（切面）： Aspect 声明类似于 Java 中的类声明，在 Aspect 中会包含着一些 Pointcut 以及相应的 Advice。

Joint point（连接点）：表示在程序中明确定义的点，典型的包括方法调用，对类成员的访问以及异常处理程序块的执行等等，它自身还可以嵌套其它 joint point。

Pointcut（切点）：表示一组 joint point，这些 joint point 或是通过逻辑关系组合起来，或是通过通配、正则表达式等方式集中起来，它定义了相应的 Advice 将要发生的地方。

Advice（增强）：Advice 定义了在 Pointcut 里面定义的程序点具体要做的操作，它通过 before、after 和 around 来区别是在每个 joint point 之前、之后还是代替执行的代码。

Target（目标对象）：织入 Advice 的目标对象。

Weaving（织入）：将 Aspect 和其他对象连接起来, 并创建 Adviced object 的过程
```

#### AOP底层实现原理

动态代理



SpringAOP入门：https://segmentfault.com/a/1190000015018888?utm_source=tag-newest

案例：https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&mid=2247483954&idx=1&sn=b34e385ed716edf6f58998ec329f9867&chksm=ebd74333dca0ca257a77c02ab458300ef982adff3cf37eb6d8d2f985f11df5cc07ef17f659d4#rd



### 3. 装配bean方式，优点和缺点是什么。⭐⭐⭐⭐

```

```





---





### SpringMVC的执行流程 ⭐⭐⭐

![](pics/springmvc_route.png)

-  一个请求匹配前端控制器 DispatcherServlet 的请求映射路径(在 web.xml中指定), WEB 容器将该请求转交给 DispatcherServlet 处理
-  DispatcherServlet 接收到请求后, 将根据 请求信息 交给 处理器映射器 （HandlerMapping）
-  HandlerMapping 根据用户的url请求 查找匹配该url的 Handler，并返回一个执行链 
-  DispatcherServlet 再请求 处理器适配器(HandlerAdapter) 调用相应的 Handler 进行处理并返回 ModelAndView 给 DispatcherServlet
-  DispatcherServlet 将 ModelAndView 请求 ViewReslover（视图解析器）解析，返回具体 View
-  DispatcherServlet 对 View 进行渲染视图（即将模型数据填充至视图中）
-  DispatcherServlet 将页面响应给用户

```
DispatcherServlet：前端控制器
用户请求到达前端控制器，它就相当于mvc模式中的c，dispatcherServlet是整个流程控制的中心，由它调用其它组件处理用户的请求，dispatcherServlet的存在降低了组件之间的耦合性。

HandlerMapping：处理器映射器
HandlerMapping负责根据用户请求url找到Handler即处理器，springmvc提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。

Handler：处理器
Handler 是继DispatcherServlet前端控制器的后端控制器，在DispatcherServlet的控制下Handler对具体的用户请求进行处理。由于Handler涉及到具体的用户业务请求，所以一般情况需要程序员根据业务需求开发Handler。

HandlAdapter：处理器适配器
通过HandlerAdapter对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。

ViewResolver：视图解析器
View Resolver负责将处理结果生成View视图，View Resolver首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成View视图对象，最后对View进行渲染将处理结果通过页面展示给用户。

View：视图
springmvc框架提供了很多的View视图类型的支持，包括：jstlView、freemarkerView、pdfView等。我们最常用的视图就是jsp。一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程序员根据业务需求开发具体的页面。
```













---



### 5. Spring是如何进行事务管理的。
### 6. Spring数据访问原理是什么。
### 
### 
### 
### 
### 
### 
### 
### 

## SpringMVC
### 1. SpringMVC的执行流程是什么？

```

```

 

## Mybatis
### 1. mybatis和hibernate的不同点，mybatis和jdbc的相同点和不同点
### 2. #{} 和${}的不同
### 3. 谈一谈动态sql
### 4. 延迟加载及缓存问题
### 
### 
### 
## Redis
### 
###
### 





## 消息队列——RabbitMQ ⭐⭐⭐
### 1.  如何保证消息能够被接受到，应用场景：比如消费者接受到一条消息之后产生了异常，实际上并不能算成功接受。

```

```



### 2. 针对生产速度比消费速度高的场景，使用什么样的消息队列模型比较适合。

```

```



### 3. 你了解目前市场上主流的消息队列吗，在你的项目中为什么要使用RabbitMQ，而不是其他的消息队列。

```

```



### 4. 如果重启RabbitMQ服务，如何保证之前消息队列中的消息能够不丢失（持久化）。



## 高阶算法

### 一致性Hash算法

```

```





















## LRU算法

```
LRU算法的核心：

```

https://crossoverjie.top/2018/04/07/algorithm/LRU-cache/

## LFU算法

```

```

https://blog.csdn.net/zxzxzx0119/article/details/81838120

https://leetcode.com/problems/lfu-cache/

**LRU和LFU的不同之处：**

```
LRU是最近最少使用页面置换算法(Least Recently Used),也就是首先淘汰最长时间未被使用的页面!
LFU是最近最不常用页面置换算法(Least Frequently Used),也就是淘汰一定时期内被访问次数最少的页!

比如,第二种方法的时期T为10分钟,如果每分钟进行一次调页,主存块为3,若所需页面走向为2 1 2 1 2 3 4
注意,当调页面4时会发生缺页中断
若按LRU算法,应换页面1(1页面最久未被使用) 但按LFU算法应换页面3(十分钟内,页面3只使用了一次)

可见LRU关键是看页面最后一次被使用到发生调度的时间长短,
而LFU关键是看一定时间段内页面被使用的频率!
```



## Top K 问题

```

```

分析时间复杂度































# 实习总结 ⭐⭐⭐⭐⭐

### 1.你在项目中遇到的最大的困难是什么？是如何解决的？

- 开发携程对应的接口，需求是给出针对携程服务CDN调度节点的信息[IP和运营商]
- 原本实现方案是直接查询跨部门API，组装JSON返回结果
- 解决问题1-给定内部接口响应太慢，使用Redis作为缓存，缓存调度信息
- 解决问题2-收到携程邮件报警信息，节点调度信息出错，Redis缓存时间设置为7天，携程访问频率为30min/，所以出现调度信息更新不及时的问题
- 尝试解决方案
    - 新增内部访问API，找一台服务器，定时访问服务（频率≈15min/），模拟携程访问，更新Redis，这种问题是OpenCDN-API后台设置了HTTP访问请求超时时间，容易更新失败
    - 直接在Centos开发机上通过crontab部署定时任务，单独配置PHP访问跨部门API，刷新Redis
- 总结
    - 考虑问题要全面，对于要上线的接口需要充分测试。
    - 重构代码的情况比较正常，开发要面向需求。

### 2. 实习收获

- 工程能力
  - 学习一门新语言的能力PHP
  - 对于新领域的学习姿势CDN

- 软技能
  - 面向需求开发，需要和mentor以及客户进行交流，弄清楚XXAPI开发的作用、以及需求。
  - 有些时候需要跨部门合作，所以需要主动和不同部门的同事进行沟通。



# Java编程技巧

```java
//1. 如何实现ArrayList数组的拷贝
List<Integer> list1 = new ArrayList<>();
list1.add();


```



# Others

- 在时间有限的情况，首先解决最核心&最高频的问题
- 做笔记是为了解决（1）知识面不够全面，面试容易掉坑 （2）高效率复习的问题































