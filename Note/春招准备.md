# 0x1  第一弹

> 根据以往经验，对于面试题不能依靠死记硬背，这样效率低下，并且很容易忘记
>
> 1. 为什么要问这样的问题
> 2. 知识之间的联系

#### Java 基础

1.JAVA中的几种基本数据类型是什么，各自占用多少字节。

1. 从占用字节少的开始枚举。(1-2-4-8，注意char占用的字节数)

2.String类能被继承吗，为什么。

1. String类还会涉及到编译器编译时优化

3.String，Stringbuffer，StringBuilder的区别。

 	1. 为什么有了String类，还需要StringBuffer和StringBuilder
 	2. 区别可以从线程安全性、效率两个方面考虑

4.ArrayList和LinkedList有什么区别。

1. 区别可以从CRUD效率、数据结构考虑

5.讲讲类的实例化顺序，比如父类静态数据，构造函数，字段，子类静态数据，构造函数，字

段，当new的时候，他们的执行顺序。

1. **父类静态代码->子类静态代码**->父类非静态代码->父类构造函数->子类非静态代码->子类构造函数
2. 涉及到JVM内存构造，但最主要是Java的类加载机制

\6. 用过哪些Map类，都有什么区别，HashMap是线程安全的吗,并发下使用的Map是什么，他们

内部原理分别是什么，比如存储方式，hashcode，扩容，默认容量等。

\7. JAVA8的ConcurrentHashMap为什么放弃了分段锁，有什么问题吗，如果你来设计，你如何

设计。

8.有没有有顺序的Map实现类，如果有，他们是怎么保证有序的。

9.抽象类和接口的区别，类可以继承多个类么，接口可以继承多个接口么,类可以实现多个接口

么。

10.继承和聚合的区别在哪。

11.IO模型有哪些，讲讲你理解的nio ，他和bio，aio的区别是啥，谈谈reactor模型。

12.反射的原理，反射创建类实例的三种方式是什么。

1. 首先要知道反射是什么（为什么要使用反射）

2. 三种方式都是针对Class对象

   ```java
   Class clz = Class.forName("java.lang.String");  //通过全路径名
   Class clz = String.class; //直接写死
   String str = new String("abc"); Class clz = str.getClass();  //通过获取的实例获取相同类型的Class对象
   ```

13**.反射中，Class.forName和ClassLoader区别 。**

1. 首先要搞懂什么是类的初始化（激活了类的静态代码块和静态变量）
2. Class.forName加载类同时进行了初始化；ClassLoader只是将类加载到了JVM中并没有进行初始化
3. Class.forName的用途（JDBC加载驱动类），ClassLoader的使用（Spring框架）

14.描述动态代理的几种实现方式，分别说出相应的优缺点。

1. 为什么需要代理（不想直接访问对象，通过代理的方式来实现访问）
2. 相对于动态代理，静态代理是什么（）
3. 

15.动态代理与cglib实现的区别。

16.为什么CGlib方式可以对接口实现代理。

17.final的用途。

1. 从修饰类（修饰的类无法继承）、修饰方法（修饰的方法无法被覆盖）、修饰变量的三个角度来分析

18.写出三种单例模式实现 。

1. 考察最基础的设计模式
   1. 懒汉式 + 饿汉式 + 登录式模式（Holder——静态内部类）+ 线程安全模式
   2. 需要注意： 构造方法 + static关键词 + (懒汉恶汉之间有什么区别)
   3. 线程安全：双重判断 + 类锁

19.如何在父类中为子类自动完成所有的hashcode和equals实现？这么做有何优劣。

20.请结合OO设计理念，谈谈访问修饰符public、private、protected、default在应用设

计中的作用。

21.深拷贝和浅拷贝区别。

1. Java中有哪两种拷贝（Shallow Copy & Deep Copy）
2. **关键在于Cloneable接口和Object.clone()方法**
   1. 浅拷贝：只对基本数据类型进行了拷贝，对引用数据类型只作为了引用的传递
   2. 深拷贝：基础数据类型拷贝√，引用数据类型拷贝创建了新的对象（然后复制成员变量）
   3. 深拷贝开辟了新的内存空间
   4. 深拷贝是一种完全拷贝，浅拷贝是一种不完全拷贝

22.数组和链表数据结构描述，各自的时间复杂度。

1. 数据结构基础

23.error和exception的区别，CheckedException，RuntimeException的区别。

1. Throwable是Error和Exception的父类![1554044272106](C:\Users\mio\AppData\Roaming\Typora\typora-user-images\1554044272106.png)
2. CheckedException ： IOException； UncheckedException ： NullPointerException

24.请列出5个运行时异常。

1. NullPointerException ：空指针异常
2. IndexOutOfBoundsException ： 下标越界异常
3. ClassNotFoundException ： 比如Class.forName()使用反射时遇到的
4. NumberFormatException ：字符串转换为数字时异常
5. ClassCastException ：类型转换异常

25**.在自己的代码中，如果创建一个java.lang.String类，这个类是否可以被类加载器加**

**载？为什么。**

1. 考察类加载的细节

26.说一说你对java.lang.Object对象中hashCode和equals方法的理解。在什么场景下需

要重新实现这两个方法。（尝试从源码去解释，以及使用的场景）

1. Object.equals ：使用==判定是否是相同对象，可以重写为判断对象属性是否相同（判断该两个对象是否相等的唯一办法）
2. Object.hashCode：native本地方法，没有具体实现（不能通过hashCode判断两个对象是否相等）
3. Object类的hashCode方法的作用：当向集合中插入对象时，如何判别在集合中是否已经存在该对象了？
4. 什么时候需要重写equals和hashCode【重写equals方法之后，需要重写HashCode方法，保证在添加到集合比如HashMap的时候能够判定为同一个对象】

27.在jdk1.5中，引入了泛型，泛型的存在是用来解决什么问题。

1. 不使用泛型的情况下：ClassCastException(联想到RuntimeException)
2. 泛型：**保证集合中的元素类型，将运行时错误提早到了编译时错误**

28.这样的a.hashcode() 有什么用，与a.equals(b)有什么关系。

29.有没有可能2个不相等的对象有相同的hashcode。

30.Java中的HashSet内部是如何工作的。

31.什么是序列化，怎么序列化，为什么序列化，反序列化会遇到什么问题，如何解决。

32.java8的新特性。

33.java中实现多态的方式

34.java为什么只支持单继承

1. 多继承的菱形关系（导致逻辑上的混乱）

35.抽象类和接口的相同点与不同点

36.Java中的volatile 变量是什么

这是一个典型的问题，但是这次我准备从不同的角度来解析volatile，这样不容易忘记~



37.反射+注解应用场景

#### Java 多线程相关问题

<http://jishu.family.baidu.com/detail?articleId=3217>



#### Java 虚拟机

<https://www.jianshu.com/p/54eb60cfa7bd>

1.内存构成

2.outofmemory来源于哪里？

3.垃圾回收算法及机制

4.java的类加载机制

5.Java 内存堆和栈的区别

6.Java 中四种引用的区别



#### Java 常用框架

spring 

1. 为什用spring，解决什么问题
   1. Spring框架管理所有对象的创建和依赖关系（IoC）
   2. Spring提供面向切面编程，方便日志和事务（AOP）
2. 核心是什么
   1. 控制反转IOC
   2. 依赖注入DI
   3. 面向切面编程AOP
3. ioc依赖注入有哪些方式？
4. 装配bean方式，优点和缺点
5. aop的原理，解决什么问题
6. spring如何进行事务管理的
7. spring的数据访问原理是怎样的

mybatis

1. mybatis和hibernate的不同点，mybatis和jdbc的相同点和不同点
2. \#{} 和${}的不同
3. ${}是Properties文件中的变量占位符，它可以用于标签属性值和sql内部，属于静态文本替换，比如${driver}会被静态替换为com.mysql.jdbc.Driver。#{}是sql的参数占位符，Mybatis会将sql中的#{}替换为?号，在sql执行前会使用PreparedStatement的参数设置方法，按序给sql的?号占位符设置参数值，比如ps.setInt(0, parameterValue)，#{[item.name](http://item.name/)}的取值方式为使用反射从参数对象中获取item对象的name属性值，相当于param.getItem().getName()。
4. 动态sql
5. 延迟加载及缓存问题



#### 数据库相关

（待补充）



#### 设计模式

常用设计模式介绍



#### 算法

<https://zhuanlan.zhihu.com/p/33683541>

1. 单链表逆置
2. 整型数组找出两个数的和为固定值SUM
3. 判断括号是否匹配，如( [ ] )是匹配的，( ( ] ]是不匹配的
4. 有一座高度是**10**级台阶的楼梯，从下往上走，每跨一步只能向上**1**级或者**2**级台阶。要求用程序来求出一共有多少种走法。
   算法详解：<http://mp.weixin.qq.com/s/IXcvbjVaLENusXECiDxLIA>
5. B树 是什么，有哪些应用场景
   <http://t.cn/R9O7bF4>



----





## Java核心技术

### final关键词

1. 被final修饰的类不能被继承
2. 被final修饰的常量只能赋值一次

### static关键词

1. 被static修饰的只能是内部类，修饰之后不需要实例化外部类就能使用
2. 被static修饰后的变量-静态变量【类加载机制】，相对于实例变量



## 集合基础

### List

#### 1. ArrayList和LinkedList的实现和区别

从实现原理、性能区别两个方面区别

1. ArrayList是通过**动态数组**（维护一个有序的一维数组）实现的
2. LinkedList是基于双向**链表**实现的

理论上：

1. ArrayList添加、删除元素涉及到数组的拷贝，比较耗时（实际情况ArrayList效率更好，一般使用ArrayList）
2. LinkedList查询元素需要遍历链表，而ArrayList能够直接返回制定位置元素

### Map

1. JDK8中HashMap的实现原理（内部数据结构和扩容时机）
2. JDK8中ConcurrentHashMap的实现原理
3. LinkedHashMap和HashMap的区别（有序）
4. Set实现原理

#### 常见问题

#### 1.  hashmap如何解决hash冲突，为什么hashmap中的链表需要转成红黑树





#### 2. hashmap什么时候会触发扩容





#### 3. jdk1.8 之前并发操作hashmap时为什么会有死循环的问题



#### 4. hashmap扩容时每个entry 需要再计算一次hash吗



#### 5. hashmap的数组长度为什么要保证是2的幂



#### 6. 如果用LinkedHashMap实现LRU（手撕算法）





#### 7. 如果用TreeMap实现一致性Hash



## JUC包



#### 常见问题：

#### 1.  CocurrentHashMap是如何在保证并发安全的时候提高性能 /  ConcurrentHashMap是如何让多线程同时参与扩容





#### 2. CopyOnWriteArrayList是如何保证线程安全的



#### 3. LinkedBlockingQueue 、 DelayQueue是如何实现的





## 并发

#### 常见问题

#### 1.  synchronized和ReentrantLock的区别

#### 2. 乐观锁和悲观锁的区别



#### 3. 如何实现一个乐观锁



#### 4. AQS是如何唤醒下一个线程的

#### 5. ReentrantLock如何实现公平锁和非公平锁

#### 6. CountDownLatch和CyclicBarrier的区别

#### 7. 适用ThreadLocal时需要注意什么？比如内存泄漏

#### 8.说一说往线程池中提交一个任务会发生什么

#### 9. 线程池的几个参数如何设置

#### 10. 线程池的非核心线程什么时候会被释放

#### 11. 如何排查死锁



## IO

### 1. BIO



### 2.NIO



#### 常见问题

#### 0. 学习Java网络编程

Ref：https://www.jianshu.com/p/ae5e1cee5b04

#### 1. 同步阻塞、同步非阻塞、异步的区别

#### 2. select、poll、epoll的区别

#### 3. Java NIO和BIO的区别

#### 4. refactor线程模型是什么



## 类加载

#### 1. 双亲委派机制的作用

#### 2. Tomcat的classloader结构

#### 3. 如何自己实现一个classloader打破双亲委派



## 引用

#### 1. 说一说Java中的软引用、弱引用、虚引用的适用场景和释放机制

- 了解Java中的引用类型有什么好处
  - 程序员可以通过代码的方式来决定程序的生命周期
  - JVM垃圾回收

1. 强引用

   ```java
   Object object = new Object()
   ```

2. 软引用

   ```java
   
   ```

3. 弱引用

4. 虚幻引用

#### 2. 软引用什么时候会被释放

#### 3. 弱引用什么时候会被释放



## JVM

#### 1. 说清楚JVM的内存划分



#### 2. 垃圾回收（GC）基本原理、几种常见的垃圾回收器的特性、重点了解CMS以及一些重要的参数

1. Java中使用可达性分析来判断对象是否符合垃圾回收的条件（一个对象到GC ROOT没有任何的引用链连接）（了解~~引用计数法~~）
2. 



#### 常见问题

#### 1. CMS GC回收分为哪几个阶段？分别做了什么事情

#### 2. CMS有哪些重要参数

#### 3. Concurrent Model Failure 和 ParNew promotion failed什么情况下会发生

#### 4. CMS的优缺点

#### 5. 有做过哪些GC调优

TODO

#### 6. 为什么要划分成年轻代和老年代

不分代也能实现功能，分代主要是为了优化GC：

1. 如果没有分代，GC的时候要找到哪些对象是没有用的，需要扫描一遍堆
2. 如果有分代，GC的时候只需要对存放生命周期短[朝生夕死]对象的区域扫描就行，节约内存空间

#### 7. 年轻代为什么被划分为eden、survivor区域

这个问题等价于：为什么需要 Survivor 空间。我们看看如果没有 Survivor 空间的话，垃圾收集将会怎样进行：一遍新生代 GC 过后，不管三七二十一，活着的对象全部进入老年代，即便它在接下来的几次 GC 过程中极有可能被回收掉。这样的话老年代很快被填满， Full GC 的频率大大增加。我们知道，老年代一般都会被规划成比新生代大很多，对它进行垃圾收集会消耗比较长的时间；如果收集的频率又很快的话，那就更糟糕了。基于这种考虑，虚拟机引进了“幸存区”的概念：如果对象在某次新生代 GC之后任然存活，让它暂时进入幸存区；以后每熬过一次 GC ，让对象的年龄＋1，直到其年龄达到某个设定的值（比如15岁）， JVM 认为它很有可能是个“老不死的”对象，再呆在幸存区没有必要（而且老是在两个幸存区之间反复地复制也需要消耗资源），才会把它转移到老年代。 

总结：如果新生代不分区，那么老年代进行Full GC的频率会增大，开销增大

#### 8. 年轻代为什么采用的是复制算法

因为存放在年轻代对象的特点就是“朝生夕死”，所以使用Copy算法的开销只是将每次GC后的少量对象拷贝到另一个分区。

#### 9. 老年代为什么采用的是标记清除、标记整理算法

老年代中的对象的特点：存活率高，没有额外空间对它进行**分配担保**

#### 10. 什么情况下使用堆外内存？要注意一些什么

Reference：https://www.jianshu.com/p/17e72bb01bf1



#### 11. 堆外内存如何被回收

#### 12. JVM内存区域划分是怎样的

1. 堆内存

   Reference：[Java中的新生代、老年代、永久代和各种GC](<http://ju.outofmemory.cn/entry/346964>)

   堆内存分为新生代（Young）-（Eden、From Survivor、To Survivor）和老年代（Old）

![](E:\校招准备\xiaozhao2019\img\堆内存模型2.png)

数据会首先分配到Eden区当中（当然也有特殊情况，如果是大对象那么会直接放入到老年代（大对象是指需要大量连续内存空间的java对象）。），当Eden没有足够空间的时候就会触发jvm发起一次Minor GC。如果对象经过一次Minor GC还存活，并且又能被Survivor空间接受，那么将被移动到Survivor空间当中。并将其年龄设为1，对象在Survivor每熬过一次Minor GC，年龄就加1，当年龄达到一定的程度（默认为15）时，就会被晋升到老年代中了，当然晋升老年代的年龄是可以设置的。

2. 本地方法栈
3. 虚拟机栈
4. 程序计数器
5. 方法区



## MySQL

1. 数据库三大范式：定义了数据库设计的原则

   (1)保证数据库的原子性

   (2)在满足第一范式的基础上，除满足第一范式外还有两个条件，一是表必须有一个主键；二是没有包含在主键中的列必须完全依赖于主键，而不能只依赖于主键的一部分。**非主属性完全依赖于主关键字。**

   (3)在满足第二范式的基础上，**任何非主属性不依赖于其它非主属性**



### MySQL索引

#### 索引的分类

索引的本质：索引是一种**文件**，它里面包含着对数据表里所有记录的引用指针

- 单列索引
  - 普通索引
  - 唯一索引
  - **主键索引**
- 组合索引：CREATE INDEX nickname_account_createdTime_Index ON `award`(`nickname`, `account`, `created_time`);

#### 







#### 常见问题

#### 1. MySQL（innondb）有哪几种事务隔离级别

| 隔离级别 | 脏读 | 不可重复读 | 幻读 |
| -------- | ---- | ---------- | ---- |
| 读未提交 | √    | √          | √    |
| 读已提交 | ×    | √          | √    |
| 可重复读 | ×    | ×          | √    |
| 串行化   | ×    | ×          | ×    |

### 数据库问题

1. 脏读：没有锁的情况下，事务A读出了其他事务没有提交的修改，非常危险
2. 不可重复读：事务A两次select的过程，事务B在中间update并且提交了，然后读出的结果不同
3. 幻读：事务A两次select的过程，事务B在中间insert/delete并且提交了，然后select出来的结果多了/少了

#### 2. 不同事务隔离级别分别会加哪些锁

#### 3. MySQL的行锁、表锁、间隙锁、意向锁分别是做什么的

#### 4. 说说什么是最左匹配

#### 5. 如何优化慢查询

#### 6. MySQL索引为什么用的是B+ Tree 而不是B Tree、红黑树

#### 7.分库分表下如何选择分表键

#### 8. 分库分表的情况下，查询时一般是如何做排序的



## Spring

#### 常见问题

#### 1.Java动态代理和cglib动态代理的区别

#### 2. Spring中bean的生命周期是怎样的

### 3. 属性注入和构造器注入哪种会有循环依赖的问题

# Spring

- 为什么要使用Spring
  - 框架：降低了组件之间的耦合性
  - 对Hibernate和MyBatis主流框架提供了支持
  - 提供了辅助类
- SpringMVC的工作原理
- 说一下自己对IoC和AOP的理解
  - Dependency Injection和Inversion of Control：Spring管理对象，通过注入的方式提供给调用者
  - Aspect Oriented Programming ：日志记录和Controller里方法执行的demo
- Spring里用到了哪些设计模式，讲一下自己对这些设计模式的理解
- Spring Bean的作用域和声明周期了解吗
- Spring事务中的隔离级别
- Spring事务的事务传播行为





# 操作系统

## 内核

####  谈一谈操作系统的用户态、系统态，两者如何转换

1. 为什么要分为内核态和用户态

   CPU的一些指令【如I/O指令，清除内存、设置时钟】比较危险（比如一个进程修改另一个进程的内存区域，导致其不能运行），所以将CPU的指令分为特权指令和非特权指令，前者只允许操作系统模块调用，普通的应用程序只能调用非特权指令。

2. 系统调用【System Call】

   定义：运行在用户空间的程序向操作系统内核请求需要更高权限运行的服务。

   作用：提供了用户程序和操作系统之间的接口【API】。

   常见的系统调用：fork创建子进程

3. Linux Kernel的作用

   （1）进程管理

   （2）内存管理

   （3）文件系统

   （4）网路管理

4.  内核态：一个进程执行系统调用陷入内核代码时，进程就处于内核态

5. 用户态什么时候会转换到内核态

   （1）系统调用：如**fork**

   （2）异常：如缺页异常

   （3）外围设备的中断

Ref：https://www.cnblogs.com/huyufeng/p/5400639.html

####  能说一下你对中断的理解吗

定义：中断是指程序在执行过程中，遇到紧急的事情需要处理，暂时中止CPU上的进程，转而去执行对应的中断处理程序，处理完毕之后返回被中断处继续执行。

#### 中断和异常有什么区别

中断【Interruption 外中断】：来自CPU执行指令以外的事件产生的中断，比如设备发出的IO中断，表示输入输出完成，希望CPU能够向设备发出下一个输入/输出请求

异常【Exception 内中断】：CPU执行指令的发生，比如程序的地址越界、算术溢出

#### 并发和并行的区别

并发【Concurrency】：一个物理CPU在若干道程序之间多路复用（微观上CPU在不断地进行进程切换）

并行【Parallel】：在多道程序环境下，多个程序在同一时刻在不同的CPU上运行

#### Fork函数

```c
#include <unistd> //unix standard 
pid_t fork(void);
```

fork函数的作用是创建一个子进程，fork函数被调用一次，但是返回两次，返回值代表进程PID

1. 父进程中，fork函数返回新创建子进程的ID
2. 子进程中，fork函数返回0
3. 出现错误（内存不够、进程数量达到上限），fork函数返回负数

从fork的地方开始，子进程复制了父进程的数据空间，两个进程开始独立运行

#### Linux下特殊的进程

1. PID = 0，idle进程，系统创建的**第一个进程**，唯一一个没有通过fork产生的进程，运行在内核态
2. PID = 1，init进程，由idle进程创建，完成系统的初始化. 是系统中所有其它用户进程的祖先进程 
   Linux中的所有进程都是有init进程创建并运行的。首先Linux内核启动，然后在用户空间中启动init进程，再启动其他系统进程。在系统启动完成完成后，init将变为守护进程监视系统其他进程。
3. PID = 2，kthread线程，由idle通过kernel_thread创建，并始终运行在内核空间, **负责所有内核线程的调度和管理**



## Linux  I/O



## 计算机网络









## 手撕算法

1. 排序：冒泡排序 / 快排 / 堆排
2. 手写LRU













# Java

- 讲一下你对内部类的理解，静态内部类和普通内部类有什么区别？
- String为什么是不可变的？String为啥要设计成不可变的
  - 源码里是`final char[]`数组形式
  - 保证不会被修改：安全性
  - 在多线程条件下也是安全的
- ConcurrentHashMap和Hashtable的区别
  - ConcurrentHashMap使用了锁分段，提高并发效率
  - 两者都是线程安全的



TODO

- [ ] 反射【IOC基础】
- [ ] 代理模式【AOP基础】
- [ ] 



### 常见问题

## Cookie和Session的对比

| 说明     | Cookie                                                       | Session                                                      |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 保存位置 | 保存在客户端                                                 | 保存在服务器                                                 |
| 工作原理 | 第一次发送请求：服务器返回Response时附带Cookie，浏览器将Cookie保存到本地；第二次发送请求：浏览器带着Cookie访问服务器 | 当客户端要求服务器产生一个session时，服务器会先检查Cookie中的session_id，如果没有session_id的话会新建session，否则将session检索出来 |
| 作用     | 确定用户身份                                                 | 相当于用户档案                                               |
| 应用     | 保存用户的登录状态                                           | 实现购物车功能                                               |
| 安全性   | 可以被修改，低                                               | 高                                                           |
| 生命周期 | 可以指定失效时间                                             | 可以设定失效时间【在没有活动的一定时间之后失效】             |

# 操作系统

## 进程和线程的区别

| 区别和联系 | 进程                                 | 线程                                       |
| ---------- | ------------------------------------ | ------------------------------------------ |
|            | 系统资源分配的最小单元               | CPU调度的基本单元                          |
| 地址空间   | 进程有自己独立的地址空间             | 同一进程中的线程共享地址空间               |
| 数据交互   | 进程之间的通信需要IPC                | 同一进程下所有的线程共享全局变量和静态变量 |
| 开销       | 创建进程需要分配地址空间，维护数据段 | 创建线程的开销小很多                       |
| 作用       | 实现操作系统的并发                   | 实现程序内的并发                           |

对于要求同时进行并且要共享变量的操作，使用线程更加方便。

## 进程间的通信方式

- 管道 pipe：
- 信号 signal： 
- 消息队列
- 共享内存
- 信号量









## 排序

### 冒泡排序

### 快速排序

### 堆排序

## Java API

### List

1. 在使用list.get(index)时首先要保证get的元素不能是null
2. addFirst()是LinkedList特有的方法而不是List接口的方法，所以在使用时需要首先(LinkedList) list将list转换为LinkedList
3. 对于`private List<List<Integer>> list = new LinkedList<List<Integer>>();` 记住是如何初始化的

## 算法注意事项

1. 越是简单的问题，越是要考虑边界条件的情况
2. 总结常见问题的坑

- [x] 手写LRU算法
  - [x] 使用HashMap+双向链表（节点定义以及手动维护），最近最新使用的节点是head指向的节点【使用head和tail两个辅助节点指针】
- [ ] topK问题 + 手写堆排序
- [x] 手写快排 | 冒泡排序
- [x] 手写生产者-消费者模型
- [ ] 字典树
- [ ] 位运算
  - [ ] 数组中异或数最大的结果值
- [ ] 动态规划
- [ ] BFS/DFS

### 二叉树总结

中序遍历打印二叉树 -> 分层打印二叉树 -> 蛇形打印二叉树【判断层数奇偶数即可】

### DFS/BFS



### MySQL乐观锁/悲观锁



## 数据库汇总

### 数据库隔离级别

| 隔离级别 | 脏读 | 不可重复读 | 幻读 |
| -------- | ---- | ---------- | ---- |
| 读未提交 | √    | √          | √    |
| 读已提交 | ×    | √          | √    |
| 可重复读 | ×    | ×          | √    |
| 串行化   | ×    | ×          | ×    |

### 数据库问题

1. 脏读：没有锁的情况下，事务A读出了其他事务没有提交的修改，非常危险
2. 不可重复读：事务A两次select的过程，事务B在中间update并且提交了，然后读出的结果不同
3. 幻读：事务A两次select的过程，事务B在中间insert/delete并且提交了，然后select出来的结果多了/少了






































